<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitrl Documentation: cengine::search::RRT&lt; NodeData, EdgeData &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">bitrl Documentation
   </div>
   <div id="projectbrief">Simulation engine for reinforcement learning agents</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecengine.html">cengine</a></li><li class="navelem"><a class="el" href="namespacecengine_1_1search.html">search</a></li><li class="navelem"><a class="el" href="classcengine_1_1search_1_1RRT.html">RRT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcengine_1_1search_1_1RRT-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">cengine::search::RRT&lt; NodeData, EdgeData &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classcengine_1_1search_1_1RRT.html" title="The RRT class models a Rapidly-Exploring Random Tree see: http://msl.cs.uiuc.edu/~lavalle/papers/Lav9...">RRT</a> class models a Rapidly-Exploring Random Tree see: <a href="http://msl.cs.uiuc.edu/~lavalle/papers/Lav98c.pdf">http://msl.cs.uiuc.edu/~lavalle/papers/Lav98c.pdf</a> The NodeData most frequently will represent the state type modeled. It corresponds to the types of <picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$x_{rand}$" src="form_23.png"/></picture> and <picture><source srcset="form_24_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$x_{new}$" src="form_24.png"/></picture> from the paper cited above. The EdgeData type corresponds to the type of <picture><source srcset="form_25_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$u$" src="form_25.png"/></picture> in the paper. It is the input that should subsequently be applied to reach from one state to another and this is what the applications most often will use.  
 <a href="classcengine_1_1search_1_1RRT.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rapidly__exploring__random__tree_8h_source.html">rapidly_exploring_random_tree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cengine::search::RRT&lt; NodeData, EdgeData &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classcengine_1_1search_1_1RRT__inherit__graph.png" border="0" usemap="#acengine_1_1search_1_1RRT_3_01NodeData_00_01EdgeData_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="acengine_1_1search_1_1RRT_3_01NodeData_00_01EdgeData_01_4_inherit__map" id="acengine_1_1search_1_1RRT_3_01NodeData_00_01EdgeData_01_4_inherit__map">
<area shape="rect" title="The RRT class models a Rapidly&#45;Exploring Random Tree see: http://msl.cs.uiuc.edu/~lavalle/papers/Lav9..." alt="" coords="5,79,193,119"/>
<area shape="rect" title=" " alt="" coords="25,5,174,31"/>
<area shape="poly" title=" " alt="" coords="102,44,102,79,97,79,97,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for cengine::search::RRT&lt; NodeData, EdgeData &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classcengine_1_1search_1_1RRT__coll__graph.png" border="0" usemap="#acengine_1_1search_1_1RRT_3_01NodeData_00_01EdgeData_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="acengine_1_1search_1_1RRT_3_01NodeData_00_01EdgeData_01_4_coll__map" id="acengine_1_1search_1_1RRT_3_01NodeData_00_01EdgeData_01_4_coll__map">
<area shape="rect" title="The RRT class models a Rapidly&#45;Exploring Random Tree see: http://msl.cs.uiuc.edu/~lavalle/papers/Lav9..." alt="" coords="5,79,193,119"/>
<area shape="rect" title=" " alt="" coords="25,5,174,31"/>
<area shape="poly" title=" " alt="" coords="102,44,102,79,97,79,97,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a83e3aaec5bf6676823436ee454df6868" id="r_a83e3aaec5bf6676823436ee454df6868"><td class="memItemLeft" align="right" valign="top">typedef NodeData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a></td></tr>
<tr class="memdesc:a83e3aaec5bf6676823436ee454df6868"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertex_data_t The type of node data  <br /></td></tr>
<tr class="separator:a83e3aaec5bf6676823436ee454df6868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cceafe221b82dc4bb20a8ab4e1a7ba2" id="r_a7cceafe221b82dc4bb20a8ab4e1a7ba2"><td class="memItemLeft" align="right" valign="top">typedef EdgeData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a7cceafe221b82dc4bb20a8ab4e1a7ba2">edge_data_t</a></td></tr>
<tr class="memdesc:a7cceafe221b82dc4bb20a8ab4e1a7ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge_data_t The type of the edge data  <br /></td></tr>
<tr class="separator:a7cceafe221b82dc4bb20a8ab4e1a7ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f4078c615d79f9eb8539bea9120244" id="r_af9f4078c615d79f9eb8539bea9120244"><td class="memItemLeft" align="right" valign="top">typedef kernel::BoostSerialGraph&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#a7cceafe221b82dc4bb20a8ab4e1a7ba2">edge_data_t</a> &gt;::vertex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a></td></tr>
<tr class="memdesc:af9f4078c615d79f9eb8539bea9120244"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertex_t the vertex type  <br /></td></tr>
<tr class="separator:af9f4078c615d79f9eb8539bea9120244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f53aa15ea3fa99a82993b705bf38fde" id="r_a7f53aa15ea3fa99a82993b705bf38fde"><td class="memItemLeft" align="right" valign="top">typedef kernel::BoostSerialGraph&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#a7cceafe221b82dc4bb20a8ab4e1a7ba2">edge_data_t</a> &gt;::edge_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a7f53aa15ea3fa99a82993b705bf38fde">edge_t</a></td></tr>
<tr class="memdesc:a7f53aa15ea3fa99a82993b705bf38fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge_t The edge type  <br /></td></tr>
<tr class="separator:a7f53aa15ea3fa99a82993b705bf38fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b82f5635ffd6c534855433c05d1b35" id="r_a78b82f5635ffd6c534855433c05d1b35"><td class="memItemLeft" align="right" valign="top">typedef kernel::BoostSerialGraph&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#a7cceafe221b82dc4bb20a8ab4e1a7ba2">edge_data_t</a> &gt;::edge_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a78b82f5635ffd6c534855433c05d1b35">edge_iterator</a></td></tr>
<tr class="memdesc:a78b82f5635ffd6c534855433c05d1b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge_iterator Edge iterator  <br /></td></tr>
<tr class="separator:a78b82f5635ffd6c534855433c05d1b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae463d65542bb7bb0157c669ea16f32f7" id="r_ae463d65542bb7bb0157c669ea16f32f7"><td class="memItemLeft" align="right" valign="top">typedef kernel::BoostSerialGraph&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#a7cceafe221b82dc4bb20a8ab4e1a7ba2">edge_data_t</a> &gt;::adjacency_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a></td></tr>
<tr class="memdesc:ae463d65542bb7bb0157c669ea16f32f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjacency_iterator Adjacency iterator  <br /></td></tr>
<tr class="separator:ae463d65542bb7bb0157c669ea16f32f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3ec5e3a09a5b0be91216f99a4743c185" id="r_a3ec5e3a09a5b0be91216f99a4743c185"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a3ec5e3a09a5b0be91216f99a4743c185">RRT</a> ()</td></tr>
<tr class="memdesc:a3ec5e3a09a5b0be91216f99a4743c185"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcengine_1_1search_1_1RRT.html" title="The RRT class models a Rapidly-Exploring Random Tree see: http://msl.cs.uiuc.edu/~lavalle/papers/Lav9...">RRT</a> Default constructor. Creates an empty tree.  <br /></td></tr>
<tr class="separator:a3ec5e3a09a5b0be91216f99a4743c185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26ce3afc60c0a2e8293bc7d1f6adfb7" id="r_ad26ce3afc60c0a2e8293bc7d1f6adfb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#ad26ce3afc60c0a2e8293bc7d1f6adfb7">get_vertex</a> (uint_t v)</td></tr>
<tr class="memdesc:ad26ce3afc60c0a2e8293bc7d1f6adfb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_vertex Returns the v-th vertex  <br /></td></tr>
<tr class="separator:ad26ce3afc60c0a2e8293bc7d1f6adfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d464dd3938ae3105af5dfc8038c5dfa" id="r_a5d464dd3938ae3105af5dfc8038c5dfa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a5d464dd3938ae3105af5dfc8038c5dfa">get_vertex</a> (uint_t v) const</td></tr>
<tr class="memdesc:a5d464dd3938ae3105af5dfc8038c5dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_vertex Returns the v-th vertex  <br /></td></tr>
<tr class="separator:a5d464dd3938ae3105af5dfc8038c5dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d4c27906581a1cd473a61fb0b47fdd" id="r_ae1d4c27906581a1cd473a61fb0b47fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#ae1d4c27906581a1cd473a61fb0b47fdd">get_vertex</a> (<a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a> itr)</td></tr>
<tr class="memdesc:ae1d4c27906581a1cd473a61fb0b47fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the vertex given the vertex descriptor This is needed when accessing the vertices using the adjacency_iterator.  <br /></td></tr>
<tr class="separator:ae1d4c27906581a1cd473a61fb0b47fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfd0d89034036d358b5cebca579dc0f" id="r_afbfd0d89034036d358b5cebca579dc0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#afbfd0d89034036d358b5cebca579dc0f">get_vertex</a> (<a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a> itr) const</td></tr>
<tr class="memdesc:afbfd0d89034036d358b5cebca579dc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the vertex given the vertex descriptor This is needed when accessing the vertices using the adjacency_iterator.  <br /></td></tr>
<tr class="separator:afbfd0d89034036d358b5cebca579dc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cb8c59af695c4ae196785113be2e42" id="r_af3cb8c59af695c4ae196785113be2e42"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#af3cb8c59af695c4ae196785113be2e42">get_vertex_neighbors</a> (uint_t id) const</td></tr>
<tr class="memdesc:af3cb8c59af695c4ae196785113be2e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the neighboring vertices for the given vertex id.  <br /></td></tr>
<tr class="separator:af3cb8c59af695c4ae196785113be2e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f1053b8d0c971390e38311f5b72fed" id="r_a32f1053b8d0c971390e38311f5b72fed"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a32f1053b8d0c971390e38311f5b72fed">get_vertex_neighbors</a> (const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;v) const</td></tr>
<tr class="memdesc:a32f1053b8d0c971390e38311f5b72fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the neighboring vertices for the given vertex id.  <br /></td></tr>
<tr class="separator:a32f1053b8d0c971390e38311f5b72fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5907b6534f7f7ed656d29a03e9425465" id="r_a5907b6534f7f7ed656d29a03e9425465"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a5907b6534f7f7ed656d29a03e9425465">add_vertex</a> (const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;node)</td></tr>
<tr class="memdesc:a5907b6534f7f7ed656d29a03e9425465"><td class="mdescLeft">&#160;</td><td class="mdescRight">add_vertex Add a new vertex to the tree  <br /></td></tr>
<tr class="separator:a5907b6534f7f7ed656d29a03e9425465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280dd7da13fad8b754a123e4bbab94fb" id="r_a280dd7da13fad8b754a123e4bbab94fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a280dd7da13fad8b754a123e4bbab94fb">add_vertex</a> (const <a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:a280dd7da13fad8b754a123e4bbab94fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new vertex in the tree that has the given data.  <br /></td></tr>
<tr class="separator:a280dd7da13fad8b754a123e4bbab94fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdf24b76f450ae9f756239639af3569" id="r_a6cdf24b76f450ae9f756239639af3569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcengine_1_1search_1_1RRT.html#a7f53aa15ea3fa99a82993b705bf38fde">edge_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a6cdf24b76f450ae9f756239639af3569">get_edge</a> (uint_t v1, uint_t v2)</td></tr>
<tr class="memdesc:a6cdf24b76f450ae9f756239639af3569"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_edge Returns the edge between the vertices v1 and v2  <br /></td></tr>
<tr class="separator:a6cdf24b76f450ae9f756239639af3569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40480a63107cc379e0cb74d4ce5109ef" id="r_a40480a63107cc379e0cb74d4ce5109ef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcengine_1_1search_1_1RRT.html#a7f53aa15ea3fa99a82993b705bf38fde">edge_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a40480a63107cc379e0cb74d4ce5109ef">get_edge</a> (uint_t v1, uint_t v2) const</td></tr>
<tr class="memdesc:a40480a63107cc379e0cb74d4ce5109ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_edge Returns the edge between the vertices v1 and v2  <br /></td></tr>
<tr class="separator:a40480a63107cc379e0cb74d4ce5109ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad635c36ed5d8345f734c1bef9f7fbc8" id="r_aad635c36ed5d8345f734c1bef9f7fbc8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#a78b82f5635ffd6c534855433c05d1b35">edge_iterator</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#a78b82f5635ffd6c534855433c05d1b35">edge_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#aad635c36ed5d8345f734c1bef9f7fbc8">edges</a> () const</td></tr>
<tr class="memdesc:aad635c36ed5d8345f734c1bef9f7fbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">edges Access the edges of the tree  <br /></td></tr>
<tr class="separator:aad635c36ed5d8345f734c1bef9f7fbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dba3dee56173665603f2038a9529cb" id="r_a88dba3dee56173665603f2038a9529cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcengine_1_1search_1_1RRT.html#a7f53aa15ea3fa99a82993b705bf38fde">edge_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a88dba3dee56173665603f2038a9529cb">add_edge</a> (uint_t v1, uint_t v2)</td></tr>
<tr class="memdesc:a88dba3dee56173665603f2038a9529cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">add_edge Add a new edge between the vertices v1 and v2  <br /></td></tr>
<tr class="separator:a88dba3dee56173665603f2038a9529cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f92fb35480fb41d8eb5d358660a58b" id="r_ad7f92fb35480fb41d8eb5d358660a58b"><td class="memTemplParams" colspan="2">template&lt;typename MetricTp &gt; </td></tr>
<tr class="memitem:ad7f92fb35480fb41d8eb5d358660a58b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#ad7f92fb35480fb41d8eb5d358660a58b">find_nearest_neighbor</a> (const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;other, const MetricTp &amp;metric) const</td></tr>
<tr class="memdesc:ad7f92fb35480fb41d8eb5d358660a58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">find_nearest_neighbor find the nearest neighbor of other node in this tree  <br /></td></tr>
<tr class="separator:ad7f92fb35480fb41d8eb5d358660a58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56694faff0eac3e96338c6a26fab8aca" id="r_a56694faff0eac3e96338c6a26fab8aca"><td class="memTemplParams" colspan="2">template&lt;typename MetricTp &gt; </td></tr>
<tr class="memitem:a56694faff0eac3e96338c6a26fab8aca"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a56694faff0eac3e96338c6a26fab8aca">find_nearest_neighbor</a> (const <a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a> &amp;other, const MetricTp &amp;metric) const</td></tr>
<tr class="memdesc:a56694faff0eac3e96338c6a26fab8aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">find_nearest_neighbor find the nearest neighbor of other node in this tree  <br /></td></tr>
<tr class="separator:a56694faff0eac3e96338c6a26fab8aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab566e9ad8dcf9db93129d6790860fb" id="r_abab566e9ad8dcf9db93129d6790860fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#abab566e9ad8dcf9db93129d6790860fb">clear</a> ()</td></tr>
<tr class="memdesc:abab566e9ad8dcf9db93129d6790860fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear Clear the underlying tree  <br /></td></tr>
<tr class="separator:abab566e9ad8dcf9db93129d6790860fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9495e948c82e9d812378ac7afb965f59" id="r_a9495e948c82e9d812378ac7afb965f59"><td class="memItemLeft" align="right" valign="top">uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a9495e948c82e9d812378ac7afb965f59">n_vertices</a> () const</td></tr>
<tr class="memdesc:a9495e948c82e9d812378ac7afb965f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">n_vertices. Returns the number of vertices of the tree  <br /></td></tr>
<tr class="separator:a9495e948c82e9d812378ac7afb965f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ef0a4b9cb5111d338b21357f093cbe" id="r_a98ef0a4b9cb5111d338b21357f093cbe"><td class="memItemLeft" align="right" valign="top">uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a98ef0a4b9cb5111d338b21357f093cbe">n_edges</a> () const</td></tr>
<tr class="memdesc:a98ef0a4b9cb5111d338b21357f093cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">n_edges. Returns the number of edges of the tree  <br /></td></tr>
<tr class="separator:a98ef0a4b9cb5111d338b21357f093cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90cf8bee66a3ea036ac4d488493316a" id="r_aa90cf8bee66a3ea036ac4d488493316a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#aa90cf8bee66a3ea036ac4d488493316a">set_show_iterations_flag</a> (bool val)</td></tr>
<tr class="memdesc:aa90cf8bee66a3ea036ac4d488493316a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_show_iterations_flag Set the show_iterations_ flag  <br /></td></tr>
<tr class="separator:aa90cf8bee66a3ea036ac4d488493316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3459af6060fc3088e22877b4456c44" id="r_afc3459af6060fc3088e22877b4456c44"><td class="memTemplParams" colspan="2">template&lt;typename StateSelector , typename MetricTp , typename DynamicsTp &gt; </td></tr>
<tr class="memitem:afc3459af6060fc3088e22877b4456c44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#afc3459af6060fc3088e22877b4456c44">build</a> (uint_t nitrs, const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;xinit, const StateSelector &amp;state_selector, const MetricTp &amp;metric, DynamicsTp &amp;dynamics)</td></tr>
<tr class="memdesc:afc3459af6060fc3088e22877b4456c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the tree.  <br /></td></tr>
<tr class="separator:afc3459af6060fc3088e22877b4456c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3782cb2827590cb68cd3b52aa03e1026" id="r_a3782cb2827590cb68cd3b52aa03e1026"><td class="memTemplParams" colspan="2">template&lt;typename StateSelector , typename MetricTp , typename DynamicsTp &gt; </td></tr>
<tr class="memitem:a3782cb2827590cb68cd3b52aa03e1026"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; bool, uint_t, uint_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcengine_1_1search_1_1RRT.html#a3782cb2827590cb68cd3b52aa03e1026">build</a> (uint_t nitrs, const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;xinit, const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;goal, const StateSelector &amp;state_selector, const MetricTp &amp;metric, DynamicsTp &amp;dynamics, real_t goal_radius)</td></tr>
<tr class="memdesc:a3782cb2827590cb68cd3b52aa03e1026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the tree by using the given goal. The tree expands as long as the specified number of nodes has not been reached or the goal is not found yet. The algorithm terminates when either the number of nodes specified is built or the goal is found.  <br /></td></tr>
<tr class="separator:a3782cb2827590cb68cd3b52aa03e1026"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename NodeData, typename EdgeData&gt;<br />
class cengine::search::RRT&lt; NodeData, EdgeData &gt;</div><p>The <a class="el" href="classcengine_1_1search_1_1RRT.html" title="The RRT class models a Rapidly-Exploring Random Tree see: http://msl.cs.uiuc.edu/~lavalle/papers/Lav9...">RRT</a> class models a Rapidly-Exploring Random Tree see: <a href="http://msl.cs.uiuc.edu/~lavalle/papers/Lav98c.pdf">http://msl.cs.uiuc.edu/~lavalle/papers/Lav98c.pdf</a> The NodeData most frequently will represent the state type modeled. It corresponds to the types of <picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$x_{rand}$" src="form_23.png"/></picture> and <picture><source srcset="form_24_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$x_{new}$" src="form_24.png"/></picture> from the paper cited above. The EdgeData type corresponds to the type of <picture><source srcset="form_25_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$u$" src="form_25.png"/></picture> in the paper. It is the input that should subsequently be applied to reach from one state to another and this is what the applications most often will use. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae463d65542bb7bb0157c669ea16f32f7" name="ae463d65542bb7bb0157c669ea16f32f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae463d65542bb7bb0157c669ea16f32f7">&#9670;&#160;</a></span>adjacency_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef kernel::BoostSerialGraph&lt;<a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a>,<a class="el" href="classcengine_1_1search_1_1RRT.html#a7cceafe221b82dc4bb20a8ab4e1a7ba2">edge_data_t</a>&gt;::adjacency_iterator <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::adjacency_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adjacency_iterator Adjacency iterator </p>

</div>
</div>
<a id="a7cceafe221b82dc4bb20a8ab4e1a7ba2" name="a7cceafe221b82dc4bb20a8ab4e1a7ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cceafe221b82dc4bb20a8ab4e1a7ba2">&#9670;&#160;</a></span>edge_data_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef EdgeData <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::edge_data_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge_data_t The type of the edge data </p>

</div>
</div>
<a id="a78b82f5635ffd6c534855433c05d1b35" name="a78b82f5635ffd6c534855433c05d1b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b82f5635ffd6c534855433c05d1b35">&#9670;&#160;</a></span>edge_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef kernel::BoostSerialGraph&lt;<a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a>,<a class="el" href="classcengine_1_1search_1_1RRT.html#a7cceafe221b82dc4bb20a8ab4e1a7ba2">edge_data_t</a>&gt;::edge_iterator <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::edge_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge_iterator Edge iterator </p>

</div>
</div>
<a id="a7f53aa15ea3fa99a82993b705bf38fde" name="a7f53aa15ea3fa99a82993b705bf38fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f53aa15ea3fa99a82993b705bf38fde">&#9670;&#160;</a></span>edge_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef kernel::BoostSerialGraph&lt;<a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a>,<a class="el" href="classcengine_1_1search_1_1RRT.html#a7cceafe221b82dc4bb20a8ab4e1a7ba2">edge_data_t</a>&gt;::edge_t <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::edge_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge_t The edge type </p>

</div>
</div>
<a id="a83e3aaec5bf6676823436ee454df6868" name="a83e3aaec5bf6676823436ee454df6868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e3aaec5bf6676823436ee454df6868">&#9670;&#160;</a></span>vertex_data_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NodeData <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::vertex_data_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vertex_data_t The type of node data </p>

</div>
</div>
<a id="af9f4078c615d79f9eb8539bea9120244" name="af9f4078c615d79f9eb8539bea9120244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f4078c615d79f9eb8539bea9120244">&#9670;&#160;</a></span>vertex_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef kernel::BoostSerialGraph&lt;<a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a>,<a class="el" href="classcengine_1_1search_1_1RRT.html#a7cceafe221b82dc4bb20a8ab4e1a7ba2">edge_data_t</a>&gt;::vertex_t <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::vertex_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vertex_t the vertex type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3ec5e3a09a5b0be91216f99a4743c185" name="a3ec5e3a09a5b0be91216f99a4743c185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec5e3a09a5b0be91216f99a4743c185">&#9670;&#160;</a></span>RRT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::RRT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classcengine_1_1search_1_1RRT.html" title="The RRT class models a Rapidly-Exploring Random Tree see: http://msl.cs.uiuc.edu/~lavalle/papers/Lav9...">RRT</a> Default constructor. Creates an empty tree. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88dba3dee56173665603f2038a9529cb" name="a88dba3dee56173665603f2038a9529cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88dba3dee56173665603f2038a9529cb">&#9670;&#160;</a></span>add_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcengine_1_1search_1_1RRT.html#a7f53aa15ea3fa99a82993b705bf38fde">edge_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::add_edge </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add_edge Add a new edge between the vertices v1 and v2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Vertex 1 </td></tr>
    <tr><td class="paramname">v2</td><td>Vertex 2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a280dd7da13fad8b754a123e4bbab94fb" name="a280dd7da13fad8b754a123e4bbab94fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280dd7da13fad8b754a123e4bbab94fb">&#9670;&#160;</a></span>add_vertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcengine_1_1search_1_1RRT.html">RRT</a>&lt; NodeData, EdgeData &gt;<a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">::vertex_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::add_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new vertex in the tree that has the given data. </p>

</div>
</div>
<a id="a5907b6534f7f7ed656d29a03e9425465" name="a5907b6534f7f7ed656d29a03e9425465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5907b6534f7f7ed656d29a03e9425465">&#9670;&#160;</a></span>add_vertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::add_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add_vertex Add a new vertex to the tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The new vertex to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc3459af6060fc3088e22877b4456c44" name="afc3459af6060fc3088e22877b4456c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3459af6060fc3088e22877b4456c44">&#9670;&#160;</a></span>build() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeTp , typename EdgeTp &gt; </div>
<div class="memtemplate">
template&lt;typename StateSelector , typename MetricTp , typename DynamicsTp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeTp, EdgeTp &gt;::build </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>nitrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>xinit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StateSelector &amp;&#160;</td>
          <td class="paramname"><em>state_selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricTp &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicsTp &amp;&#160;</td>
          <td class="paramname"><em>dynamics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the tree. </p>

</div>
</div>
<a id="a3782cb2827590cb68cd3b52aa03e1026" name="a3782cb2827590cb68cd3b52aa03e1026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3782cb2827590cb68cd3b52aa03e1026">&#9670;&#160;</a></span>build() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename StateSelector , typename MetricTp , typename DynamicsTp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, uint_t, uint_t &gt; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::build </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>nitrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>xinit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>goal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StateSelector &amp;&#160;</td>
          <td class="paramname"><em>state_selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricTp &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicsTp &amp;&#160;</td>
          <td class="paramname"><em>dynamics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>goal_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the tree by using the given goal. The tree expands as long as the specified number of nodes has not been reached or the goal is not found yet. The algorithm terminates when either the number of nodes specified is built or the goal is found. </p>

</div>
</div>
<a id="abab566e9ad8dcf9db93129d6790860fb" name="abab566e9ad8dcf9db93129d6790860fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab566e9ad8dcf9db93129d6790860fb">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clear Clear the underlying tree </p>

</div>
</div>
<a id="aad635c36ed5d8345f734c1bef9f7fbc8" name="aad635c36ed5d8345f734c1bef9f7fbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad635c36ed5d8345f734c1bef9f7fbc8">&#9670;&#160;</a></span>edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#a78b82f5635ffd6c534855433c05d1b35">edge_iterator</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#a78b82f5635ffd6c534855433c05d1b35">edge_iterator</a> &gt; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>edges Access the edges of the tree </p>

</div>
</div>
<a id="a56694faff0eac3e96338c6a26fab8aca" name="a56694faff0eac3e96338c6a26fab8aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56694faff0eac3e96338c6a26fab8aca">&#9670;&#160;</a></span>find_nearest_neighbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename MetricTp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcengine_1_1search_1_1RRT.html">RRT</a>&lt; NodeData, EdgeData &gt;<a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">::vertex_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::find_nearest_neighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcengine_1_1search_1_1RRT.html#a83e3aaec5bf6676823436ee454df6868">vertex_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricTp &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find_nearest_neighbor find the nearest neighbor of other node in this tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The node for which to find the nearest neighbor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad7f92fb35480fb41d8eb5d358660a58b" name="ad7f92fb35480fb41d8eb5d358660a58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f92fb35480fb41d8eb5d358660a58b">&#9670;&#160;</a></span>find_nearest_neighbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<div class="memtemplate">
template&lt;typename MetricTp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcengine_1_1search_1_1RRT.html">RRT</a>&lt; NodeData, EdgeData &gt;<a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">::vertex_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::find_nearest_neighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricTp &amp;&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find_nearest_neighbor find the nearest neighbor of other node in this tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The node for which to find the nearest neighbor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a6cdf24b76f450ae9f756239639af3569" name="a6cdf24b76f450ae9f756239639af3569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdf24b76f450ae9f756239639af3569">&#9670;&#160;</a></span>get_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcengine_1_1search_1_1RRT.html#a7f53aa15ea3fa99a82993b705bf38fde">edge_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::get_edge </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get_edge Returns the edge between the vertices v1 and v2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Vertex 1 </td></tr>
    <tr><td class="paramname">v2</td><td>Vertex 2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40480a63107cc379e0cb74d4ce5109ef" name="a40480a63107cc379e0cb74d4ce5109ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40480a63107cc379e0cb74d4ce5109ef">&#9670;&#160;</a></span>get_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcengine_1_1search_1_1RRT.html#a7f53aa15ea3fa99a82993b705bf38fde">edge_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::get_edge </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get_edge Returns the edge between the vertices v1 and v2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Vertex 1 </td></tr>
    <tr><td class="paramname">v2</td><td>Vertex 2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1d4c27906581a1cd473a61fb0b47fdd" name="ae1d4c27906581a1cd473a61fb0b47fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d4c27906581a1cd473a61fb0b47fdd">&#9670;&#160;</a></span>get_vertex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::get_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a>&#160;</td>
          <td class="paramname"><em>itr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the vertex given the vertex descriptor This is needed when accessing the vertices using the adjacency_iterator. </p>

</div>
</div>
<a id="afbfd0d89034036d358b5cebca579dc0f" name="afbfd0d89034036d358b5cebca579dc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfd0d89034036d358b5cebca579dc0f">&#9670;&#160;</a></span>get_vertex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::get_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a>&#160;</td>
          <td class="paramname"><em>itr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the vertex given the vertex descriptor This is needed when accessing the vertices using the adjacency_iterator. </p>

</div>
</div>
<a id="ad26ce3afc60c0a2e8293bc7d1f6adfb7" name="ad26ce3afc60c0a2e8293bc7d1f6adfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26ce3afc60c0a2e8293bc7d1f6adfb7">&#9670;&#160;</a></span>get_vertex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::get_vertex </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get_vertex Returns the v-th vertex </p>

</div>
</div>
<a id="a5d464dd3938ae3105af5dfc8038c5dfa" name="a5d464dd3938ae3105af5dfc8038c5dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d464dd3938ae3105af5dfc8038c5dfa">&#9670;&#160;</a></span>get_vertex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::get_vertex </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get_vertex Returns the v-th vertex </p>

</div>
</div>
<a id="a32f1053b8d0c971390e38311f5b72fed" name="a32f1053b8d0c971390e38311f5b72fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f1053b8d0c971390e38311f5b72fed">&#9670;&#160;</a></span>get_vertex_neighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a> &gt; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::get_vertex_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcengine_1_1search_1_1RRT.html#af9f4078c615d79f9eb8539bea9120244">vertex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the neighboring vertices for the given vertex id. </p>

</div>
</div>
<a id="af3cb8c59af695c4ae196785113be2e42" name="af3cb8c59af695c4ae196785113be2e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cb8c59af695c4ae196785113be2e42">&#9670;&#160;</a></span>get_vertex_neighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a>, <a class="el" href="classcengine_1_1search_1_1RRT.html#ae463d65542bb7bb0157c669ea16f32f7">adjacency_iterator</a> &gt; <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::get_vertex_neighbors </td>
          <td>(</td>
          <td class="paramtype">uint_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the neighboring vertices for the given vertex id. </p>

</div>
</div>
<a id="a98ef0a4b9cb5111d338b21357f093cbe" name="a98ef0a4b9cb5111d338b21357f093cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ef0a4b9cb5111d338b21357f093cbe">&#9670;&#160;</a></span>n_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint_t <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::n_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>n_edges. Returns the number of edges of the tree </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9495e948c82e9d812378ac7afb965f59" name="a9495e948c82e9d812378ac7afb965f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9495e948c82e9d812378ac7afb965f59">&#9670;&#160;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint_t <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>n_vertices. Returns the number of vertices of the tree </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa90cf8bee66a3ea036ac4d488493316a" name="aa90cf8bee66a3ea036ac4d488493316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90cf8bee66a3ea036ac4d488493316a">&#9670;&#160;</a></span>set_show_iterations_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeData , typename EdgeData &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcengine_1_1search_1_1RRT.html">cengine::search::RRT</a>&lt; NodeData, EdgeData &gt;::set_show_iterations_flag </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set_show_iterations_flag Set the show_iterations_ flag </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libs/cuberl/include/cuberl/planning/<a class="el" href="rapidly__exploring__random__tree_8h_source.html">rapidly_exploring_random_tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
