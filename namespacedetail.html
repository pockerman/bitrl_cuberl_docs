<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitrl Documentation: detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">bitrl Documentation
   </div>
   <div id="projectbrief">Simulation engine for reinforcement learning agents</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">detail Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>detail namespace with internal helper functions  
<a href="namespacedetail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedetail_1_1container__input__adapter__factory__impl" id="r_namespacedetail_1_1container__input__adapter__factory__impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail_1_1container__input__adapter__factory__impl.html">container_input_adapter_factory_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedetail_1_1dtoa__impl" id="r_namespacedetail_1_1dtoa__impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail_1_1dtoa__impl.html">dtoa_impl</a></td></tr>
<tr class="memdesc:namespacedetail_1_1dtoa__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements the Grisu2 algorithm for binary to decimal floating-point conversion. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedetail_1_1impl" id="r_namespacedetail_1_1impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedetail_1_1utility__internal" id="r_namespacedetail_1_1utility__internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail_1_1utility__internal.html">utility_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1actual__object__comparator.html">actual_object_comparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1binary__reader.html">binary_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialization of CBOR, MessagePack, and UBJSON values  <a href="classdetail_1_1binary__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1char__traits.html">char_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1char__traits_3_01signed_01char_01_4.html">char_traits&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1char__traits_3_01unsigned_01char_01_4.html">char_traits&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1conjunction.html">conjunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1conjunction_3_01B_01_4.html">conjunction&lt; B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1conjunction_3_01B_00_01Bn_8_8_8_01_4.html">conjunction&lt; B, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1detector.html">detector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1detector_3_01Default_00_01void__t_3_01Op_3_01Args_8_8_8_01_4_01_4_00_01Op_00_01Args_8_8_8_01_4.html">detector&lt; Default, void_t&lt; Op&lt; Args... &gt; &gt;, Op, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1exception.html">exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">general exception of the <a class="el" href="classbasic__json.html">basic_json</a> class  <a href="classdetail_1_1exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1external__constructor.html">external_constructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1external__constructor_3_01value__t_1_1array_01_4.html">external_constructor&lt; value_t::array &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1external__constructor_3_01value__t_1_1binary_01_4.html">external_constructor&lt; value_t::binary &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1external__constructor_3_01value__t_1_1boolean_01_4.html">external_constructor&lt; value_t::boolean &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1external__constructor_3_01value__t_1_1number__float_01_4.html">external_constructor&lt; value_t::number_float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1external__constructor_3_01value__t_1_1number__integer_01_4.html">external_constructor&lt; value_t::number_integer &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1external__constructor_3_01value__t_1_1number__unsigned_01_4.html">external_constructor&lt; value_t::number_unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1external__constructor_3_01value__t_1_1object_01_4.html">external_constructor&lt; value_t::object &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1external__constructor_3_01value__t_1_1string_01_4.html">external_constructor&lt; value_t::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1has__from__json.html">has_from_json</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1has__from__json_3_01BasicJsonType_00_01T_00_01enable__if__t_3_01_9is__basic__json_3_01T_01_4_1_1value_01_4_01_4.html">has_from_json&lt; BasicJsonType, T, enable_if_t&lt; !is_basic_json&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1has__key__compare.html">has_key_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1has__non__default__from__json.html">has_non_default_from_json</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1has__non__default__from__json_3_01BasicJsonType_00_01T_00_01enable__if__t_3_01_912047717fa07cfa9d99fe9eafcf1e11e.html">has_non_default_from_json&lt; BasicJsonType, T, enable_if_t&lt; !is_basic_json&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1has__to__json.html">has_to_json</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1has__to__json_3_01BasicJsonType_00_01T_00_01enable__if__t_3_01_9is__basic__json_3_01T_01_4_1_1value_01_4_01_4.html">has_to_json&lt; BasicJsonType, T, enable_if_t&lt; !is_basic_json&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1integer__sequence.html">integer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1internal__iterator.html">internal_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an iterator value  <a href="structdetail_1_1internal__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1invalid__iterator.html">invalid_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception indicating errors with iterators  <a href="classdetail_1_1invalid__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__basic__json.html">is_basic_json</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__basic__json_3_01NLOHMANN__BASIC__JSON__TPL_01_4.html">is_basic_json&lt; NLOHMANN_BASIC_JSON_TPL &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__basic__json__context.html">is_basic_json_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__c__string.html">is_c_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__comparable.html">is_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__comparable_3_01Compare_00_01A_00_01B_00_01void__t_3_01decltype_07std_1_1decle5e3400d312093eca0a7154409c6a227.html">is_comparable&lt; Compare, A, B, void_t&lt; decltype(std::declval&lt; Compare &gt;()(std::declval&lt; A &gt;(), std::declval&lt; B &gt;())), decltype(std::declval&lt; Compare &gt;()(std::declval&lt; B &gt;(), std::declval&lt; A &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__array__type.html">is_compatible_array_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__array__type__impl.html">is_compatible_array_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__array__type__impl_3_01BasicJsonType_00_01CompatibleArrayType_00_ba7b30737b5c65ad9adb609a3762b85a.html">is_compatible_array_type_impl&lt; BasicJsonType, CompatibleArrayType, enable_if_t&lt; is_detected&lt; iterator_t, CompatibleArrayType &gt;::value &amp;&amp;is_iterator_traits&lt; iterator_traits&lt; detected_t&lt; iterator_t, CompatibleArrayType &gt; &gt; &gt;::value &amp;&amp;!std::is_same&lt; CompatibleArrayType, detected_t&lt; range_value_t, CompatibleArrayType &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__integer__type.html">is_compatible_integer_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__integer__type__impl.html">is_compatible_integer_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__integer__type__impl_3_01RealIntegerType_00_01CompatibleNumberInt5b484fcfc2d1ae63b1211da72eabe33b.html">is_compatible_integer_type_impl&lt; RealIntegerType, CompatibleNumberIntegerType, enable_if_t&lt; std::is_integral&lt; RealIntegerType &gt;::value &amp;&amp;std::is_integral&lt; CompatibleNumberIntegerType &gt;::value &amp;&amp;!std::is_same&lt; bool, CompatibleNumberIntegerType &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__object__type.html">is_compatible_object_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__object__type__impl.html">is_compatible_object_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__object__type__impl_3_01BasicJsonType_00_01CompatibleObjectType_01530c59509aa77cdb5f1e95cf109944f.html">is_compatible_object_type_impl&lt; BasicJsonType, CompatibleObjectType, enable_if_t&lt; is_detected&lt; mapped_type_t, CompatibleObjectType &gt;::value &amp;&amp;is_detected&lt; key_type_t, CompatibleObjectType &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__string__type.html">is_compatible_string_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__type.html">is_compatible_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__type__impl.html">is_compatible_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__compatible__type__impl_3_01BasicJsonType_00_01CompatibleType_00_01enable__if67e19080e9bd0cd565bd49f604895399.html">is_compatible_type_impl&lt; BasicJsonType, CompatibleType, enable_if_t&lt; is_complete_type&lt; CompatibleType &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__complete__type.html">is_complete_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__complete__type_3_01T_00_01decltype_07void_07sizeof_07T_08_08_08_4.html">is_complete_type&lt; T, decltype(void(sizeof(T)))&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible.html">is_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible_3_01const_01std_1_1pair_3_01T1_00_01T2_01_4_01_4.html">is_constructible&lt; const std::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible_3_01const_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_constructible&lt; const std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible_3_01std_1_1pair_3_01T1_00_01T2_01_4_01_4.html">is_constructible&lt; std::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_constructible&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__array__type.html">is_constructible_array_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__array__type__impl.html">is_constructible_array_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__array__type__impl_3_01BasicJsonType_00_01ConstructibleArrayTy3a773789b90b07cf1d15e358c6d585ac.html">is_constructible_array_type_impl&lt; BasicJsonType, ConstructibleArrayType, enable_if_t&lt; !std::is_same&lt; ConstructibleArrayType, typename BasicJsonType::value_type &gt;::value &amp;&amp;!is_compatible_string_type&lt; BasicJsonType, ConstructibleArrayType &gt;::value &amp;&amp;is_default_constructible&lt; ConstructibleArrayType &gt;::value &amp;&amp;(std::is_move_assignable&lt; ConstructibleArrayType &gt;::value||std::is_copy_assignable&lt; ConstructibleArrayType &gt;::value)&amp;&amp;is_detected&lt; iterator_t, ConstructibleArrayType &gt;::value &amp;&amp;is_iterator_traits&lt; iterator_traits&lt; detected_t&lt; iterator_t, ConstructibleArrayType &gt; &gt; &gt;::value &amp;&amp;is_detected&lt; range_value_t, ConstructibleArrayType &gt;::value &amp;&amp;!std::is_same&lt; ConstructibleArrayType, detected_t&lt; range_value_t, ConstructibleArrayType &gt; &gt;::value &amp;&amp;is_complete_type&lt; detected_t&lt; range_value_t, ConstructibleArrayType &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__array__type__impl_3_01BasicJsonType_00_01ConstructibleArrayTyff4af2af9684a1cc8580410ec8c319a4.html">is_constructible_array_type_impl&lt; BasicJsonType, ConstructibleArrayType, enable_if_t&lt; std::is_same&lt; ConstructibleArrayType, typename BasicJsonType::value_type &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__object__type.html">is_constructible_object_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__object__type__impl.html">is_constructible_object_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__object__type__impl_3_01BasicJsonType_00_01ConstructibleObject435b838380c31b9738383402f7bb5943.html">is_constructible_object_type_impl&lt; BasicJsonType, ConstructibleObjectType, enable_if_t&lt; is_detected&lt; mapped_type_t, ConstructibleObjectType &gt;::value &amp;&amp;is_detected&lt; key_type_t, ConstructibleObjectType &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__string__type.html">is_constructible_string_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__tuple.html">is_constructible_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__constructible__tuple_3_01T1_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">is_constructible_tuple&lt; T1, std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__default__constructible.html">is_default_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__default__constructible_3_01const_01std_1_1pair_3_01T1_00_01T2_01_4_01_4.html">is_default_constructible&lt; const std::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__default__constructible_3_01const_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_default_constructible&lt; const std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__default__constructible_3_01std_1_1pair_3_01T1_00_01T2_01_4_01_4.html">is_default_constructible&lt; std::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__default__constructible_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_default_constructible&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__detected__lazy.html">is_detected_lazy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__getable.html">is_getable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__iterator__traits.html">is_iterator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__iterator__traits_3_01iterator__traits_3_01T_01_4_01_4.html">is_iterator_traits&lt; iterator_traits&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__json__iterator__of.html">is_json_iterator_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__json__iterator__of_3_01BasicJsonType_00_01typename_01BasicJsonType_1_1const__iterator_01_4.html">is_json_iterator_of&lt; BasicJsonType, typename BasicJsonType::const_iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__json__iterator__of_3_01BasicJsonType_00_01typename_01BasicJsonType_1_1iterator_01_4.html">is_json_iterator_of&lt; BasicJsonType, typename BasicJsonType::iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__json__ref.html">is_json_ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__json__ref_3_01json__ref_3_01T_01_4_01_4.html">is_json_ref&lt; json_ref&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__ordered__map.html">is_ordered_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__range.html">is_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__specialization__of.html">is_specialization_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__specialization__of_3_01Primary_00_01Primary_3_01Args_8_8_8_01_4_01_4.html">is_specialization_of&lt; Primary, Primary&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1is__transparent.html">is_transparent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1iter__impl.html">iter_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a template for a bidirectional iterator for the <a class="el" href="classbasic__json.html">basic_json</a> class This class implements a both iterators (iterator and const_iterator) for the <a class="el" href="classbasic__json.html">basic_json</a> class.  <a href="classdetail_1_1iter__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1iteration__proxy.html">iteration_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">proxy class for the items() function  <a href="classdetail_1_1iteration__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1iteration__proxy__value.html">iteration_proxy_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1iterator__traits_3_01T_01_5_00_01enable__if__t_3_01std_1_1is__object_3_01T_01_4_1_1value_01_4_01_4.html">iterator_traits&lt; T *, enable_if_t&lt; std::is_object&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1iterator__traits_3_01T_00_01enable__if__t_3_01_9std_1_1is__pointer_3_01T_01_4_1_1value_01_4_01_4.html">iterator_traits&lt; T, enable_if_t&lt; !std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1iterator__types.html">iterator_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1iterator__types_3_01It_00_01void__t_3_01typename_01It_1_1difference__type_00_01tce77e1bdc2e5b392df295e4bdf270278.html">iterator_types&lt; It, void_t&lt; typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1json__default__base.html">json_default_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default base class of the <a class="el" href="classbasic__json.html">basic_json</a> class.  <a href="structdetail_1_1json__default__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1json__ref.html">json_ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1json__reverse__iterator.html">json_reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a template for a reverse iterator class  <a href="classdetail_1_1json__reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1json__sax__acceptor.html">json_sax_acceptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1json__sax__dom__callback__parser.html">json_sax_dom_callback_parser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1json__sax__dom__parser.html">json_sax_dom_parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SAX implementation to create a JSON value from SAX events.  <a href="classdetail_1_1json__sax__dom__parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1lexer.html">lexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">lexical analysis  <a href="classdetail_1_1lexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1lexer__base.html">lexer_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1make__void.html">make_void</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1negation.html">negation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1nonesuch.html">nonesuch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1other__error.html">other_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception indicating other library errors  <a href="classdetail_1_1other__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1out__of__range.html">out_of_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception indicating access out of the defined range  <a href="classdetail_1_1out__of__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1parse__error.html">parse_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception indicating a parse error  <a href="classdetail_1_1parse__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1position__t.html">position_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct to capture the start position of the current token  <a href="structdetail_1_1position__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1priority__tag.html">priority_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1priority__tag_3_010_01_4.html">priority_tag&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1serializer.html">serializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1static__const.html">static_const</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1to__json__fn.html">to_json_fn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdetail_1_1type__error.html">type_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception indicating executing a member function with a wrong type  <a href="classdetail_1_1type__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1value__in__range__of__impl1.html">value_in_range_of_impl1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1value__in__range__of__impl1_3_01OfType_00_01T_00_01false_01_4.html">value_in_range_of_impl1&lt; OfType, T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1value__in__range__of__impl1_3_01OfType_00_01T_00_01true_01_4.html">value_in_range_of_impl1&lt; OfType, T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1value__in__range__of__impl2.html">value_in_range_of_impl2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1value__in__range__of__impl2_3_01OfType_00_01T_00_01false_00_01false_01_4.html">value_in_range_of_impl2&lt; OfType, T, false, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1value__in__range__of__impl2_3_01OfType_00_01T_00_01false_00_01true_01_4.html">value_in_range_of_impl2&lt; OfType, T, false, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1value__in__range__of__impl2_3_01OfType_00_01T_00_01true_00_01false_01_4.html">value_in_range_of_impl2&lt; OfType, T, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetail_1_1value__in__range__of__impl2_3_01OfType_00_01T_00_01true_00_01true_01_4.html">value_in_range_of_impl2&lt; OfType, T, true, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a138aa0af34e28b5a1032f00c712d376b" id="r_a138aa0af34e28b5a1032f00c712d376b"><td class="memTemplParams" colspan="2">template&lt;typename ... Ts&gt; </td></tr>
<tr class="memitem:a138aa0af34e28b5a1032f00c712d376b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a138aa0af34e28b5a1032f00c712d376b">void_t</a> = typename <a class="el" href="structdetail_1_1make__void.html">make_void</a>&lt; Ts... &gt;::type</td></tr>
<tr class="separator:a138aa0af34e28b5a1032f00c712d376b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af040ff7b29d4c7ebd4dc6062bb3db008" id="r_af040ff7b29d4c7ebd4dc6062bb3db008"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:af040ff7b29d4c7ebd4dc6062bb3db008"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a> = typename <a class="el" href="structdetail_1_1detector.html">detector</a>&lt; <a class="el" href="structdetail_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">::value_t</a></td></tr>
<tr class="separator:af040ff7b29d4c7ebd4dc6062bb3db008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7d25c4bee06898292dff4eb4e381bf" id="r_a9d7d25c4bee06898292dff4eb4e381bf"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a9d7d25c4bee06898292dff4eb4e381bf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a9d7d25c4bee06898292dff4eb4e381bf">detected_t</a> = typename <a class="el" href="structdetail_1_1detector.html">detector</a>&lt; <a class="el" href="structdetail_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;::type</td></tr>
<tr class="separator:a9d7d25c4bee06898292dff4eb4e381bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f58658f7add3da8b8b976f181fa38e0" id="r_a7f58658f7add3da8b8b976f181fa38e0"><td class="memTemplParams" colspan="2">template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a7f58658f7add3da8b8b976f181fa38e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a7f58658f7add3da8b8b976f181fa38e0">detected_or</a> = <a class="el" href="structdetail_1_1detector.html">detector</a>&lt; Default, void, Op, Args... &gt;</td></tr>
<tr class="separator:a7f58658f7add3da8b8b976f181fa38e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8c357df0fc3008a19bf4dca3bedcc9" id="r_a7c8c357df0fc3008a19bf4dca3bedcc9"><td class="memTemplParams" colspan="2">template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a7c8c357df0fc3008a19bf4dca3bedcc9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a7c8c357df0fc3008a19bf4dca3bedcc9">detected_or_t</a> = typename <a class="el" href="namespacedetail.html#a7f58658f7add3da8b8b976f181fa38e0">detected_or</a>&lt; Default, Op, Args... &gt;::type</td></tr>
<tr class="separator:a7c8c357df0fc3008a19bf4dca3bedcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0f7c3e1f48f7df9b5bbceada5b1a07" id="r_a0f0f7c3e1f48f7df9b5bbceada5b1a07"><td class="memTemplParams" colspan="2">template&lt;class Expected , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a0f0f7c3e1f48f7df9b5bbceada5b1a07"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a0f0f7c3e1f48f7df9b5bbceada5b1a07">is_detected_exact</a> = std::is_same&lt; Expected, <a class="el" href="namespacedetail.html#a9d7d25c4bee06898292dff4eb4e381bf">detected_t</a>&lt; Op, Args... &gt; &gt;</td></tr>
<tr class="separator:a0f0f7c3e1f48f7df9b5bbceada5b1a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599dfec0fd1c4cc9fcaa98e6fc804e7f" id="r_a599dfec0fd1c4cc9fcaa98e6fc804e7f"><td class="memTemplParams" colspan="2">template&lt;class To , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a599dfec0fd1c4cc9fcaa98e6fc804e7f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a599dfec0fd1c4cc9fcaa98e6fc804e7f">is_detected_convertible</a> = std::is_convertible&lt; <a class="el" href="namespacedetail.html#a9d7d25c4bee06898292dff4eb4e381bf">detected_t</a>&lt; Op, Args... &gt;, To &gt;</td></tr>
<tr class="separator:a599dfec0fd1c4cc9fcaa98e6fc804e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76afb2c3a23eb88e7efb7c5d5499574" id="r_ad76afb2c3a23eb88e7efb7c5d5499574"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad76afb2c3a23eb88e7efb7c5d5499574"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">uncvref_t</a> = typename std::remove_cv&lt; typename std::remove_reference&lt; T &gt;::type &gt;::type</td></tr>
<tr class="separator:ad76afb2c3a23eb88e7efb7c5d5499574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bbcd629c83a87ba9cbc72a675cf84a" id="r_a66bbcd629c83a87ba9cbc72a675cf84a"><td class="memTemplParams" colspan="2">template&lt;bool B, typename T  = void&gt; </td></tr>
<tr class="memitem:a66bbcd629c83a87ba9cbc72a675cf84a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a> = typename std::enable_if&lt; B, T &gt;::type</td></tr>
<tr class="separator:a66bbcd629c83a87ba9cbc72a675cf84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6f1f2e94159041593901afc8f0c9b0" id="r_a4e6f1f2e94159041593901afc8f0c9b0"><td class="memTemplParams" colspan="2">template&lt;size_t... Ints&gt; </td></tr>
<tr class="memitem:a4e6f1f2e94159041593901afc8f0c9b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a4e6f1f2e94159041593901afc8f0c9b0">index_sequence</a> = <a class="el" href="structdetail_1_1integer__sequence.html">integer_sequence</a>&lt; size_t, Ints... &gt;</td></tr>
<tr class="separator:a4e6f1f2e94159041593901afc8f0c9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517a072d9de78dcbc9c44c39f75a0d92" id="r_a517a072d9de78dcbc9c44c39f75a0d92"><td class="memTemplParams" colspan="2">template&lt;typename T , T N&gt; </td></tr>
<tr class="memitem:a517a072d9de78dcbc9c44c39f75a0d92"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a517a072d9de78dcbc9c44c39f75a0d92">make_integer_sequence</a> = typename <a class="el" href="structdetail_1_1utility__internal_1_1Gen.html">utility_internal::Gen</a>&lt; T, N &gt;::type</td></tr>
<tr class="separator:a517a072d9de78dcbc9c44c39f75a0d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dd889f447e7a1383b8757be27f66e9" id="r_a82dd889f447e7a1383b8757be27f66e9"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a82dd889f447e7a1383b8757be27f66e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a82dd889f447e7a1383b8757be27f66e9">make_index_sequence</a> = <a class="el" href="namespacedetail.html#a517a072d9de78dcbc9c44c39f75a0d92">make_integer_sequence</a>&lt; size_t, N &gt;</td></tr>
<tr class="separator:a82dd889f447e7a1383b8757be27f66e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cab3320b7c6d98af3ddf06c1a6b112" id="r_ad2cab3320b7c6d98af3ddf06c1a6b112"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad2cab3320b7c6d98af3ddf06c1a6b112"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ad2cab3320b7c6d98af3ddf06c1a6b112">index_sequence_for</a> = <a class="el" href="namespacedetail.html#a82dd889f447e7a1383b8757be27f66e9">make_index_sequence</a>&lt; sizeof...(Ts)&gt;</td></tr>
<tr class="separator:ad2cab3320b7c6d98af3ddf06c1a6b112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0f5d9b1fa1f5ed1be64165f3cf887f" id="r_a6f0f5d9b1fa1f5ed1be64165f3cf887f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f0f5d9b1fa1f5ed1be64165f3cf887f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a6f0f5d9b1fa1f5ed1be64165f3cf887f">mapped_type_t</a> = typename T::mapped_type</td></tr>
<tr class="separator:a6f0f5d9b1fa1f5ed1be64165f3cf887f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e60ec97eaa2afdff62c6217cbbbd747" id="r_a8e60ec97eaa2afdff62c6217cbbbd747"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e60ec97eaa2afdff62c6217cbbbd747"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a8e60ec97eaa2afdff62c6217cbbbd747">key_type_t</a> = typename T::key_type</td></tr>
<tr class="separator:a8e60ec97eaa2afdff62c6217cbbbd747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f74b6382403d25215a9433897255b4" id="r_a53f74b6382403d25215a9433897255b4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53f74b6382403d25215a9433897255b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a53f74b6382403d25215a9433897255b4">value_type_t</a> = typename T::value_type</td></tr>
<tr class="separator:a53f74b6382403d25215a9433897255b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e225ffcce63aef0a259e2c6bd839c1" id="r_ad4e225ffcce63aef0a259e2c6bd839c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4e225ffcce63aef0a259e2c6bd839c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ad4e225ffcce63aef0a259e2c6bd839c1">difference_type_t</a> = typename T::difference_type</td></tr>
<tr class="separator:ad4e225ffcce63aef0a259e2c6bd839c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f3f767ccb40a3a5db595b172207340" id="r_a41f3f767ccb40a3a5db595b172207340"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41f3f767ccb40a3a5db595b172207340"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a41f3f767ccb40a3a5db595b172207340">pointer_t</a> = typename T::pointer</td></tr>
<tr class="separator:a41f3f767ccb40a3a5db595b172207340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10a42b2797e1b62417091ff3d330832" id="r_ae10a42b2797e1b62417091ff3d330832"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae10a42b2797e1b62417091ff3d330832"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ae10a42b2797e1b62417091ff3d330832">reference_t</a> = typename T::reference</td></tr>
<tr class="separator:ae10a42b2797e1b62417091ff3d330832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e68a64b10d08b88f50a96c4f968be2" id="r_aa2e68a64b10d08b88f50a96c4f968be2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2e68a64b10d08b88f50a96c4f968be2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aa2e68a64b10d08b88f50a96c4f968be2">iterator_category_t</a> = typename T::iterator_category</td></tr>
<tr class="separator:aa2e68a64b10d08b88f50a96c4f968be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a52995475a3d1522a15e7a8200c59e" id="r_a30a52995475a3d1522a15e7a8200c59e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a30a52995475a3d1522a15e7a8200c59e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a30a52995475a3d1522a15e7a8200c59e">to_json_function</a> = decltype(T::to_json(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="separator:a30a52995475a3d1522a15e7a8200c59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0993334c14a7e8055e1ec5ff237133" id="r_a7d0993334c14a7e8055e1ec5ff237133"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a7d0993334c14a7e8055e1ec5ff237133"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a7d0993334c14a7e8055e1ec5ff237133">from_json_function</a> = decltype(T::from_json(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="separator:a7d0993334c14a7e8055e1ec5ff237133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34780011ee13a3ede041ddcee288f484" id="r_a34780011ee13a3ede041ddcee288f484"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a34780011ee13a3ede041ddcee288f484"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a34780011ee13a3ede041ddcee288f484">get_template_function</a> = decltype(std::declval&lt; T &gt;().template <a class="el" href="namespacedetail.html#a7116703ea757fe9821bf2e903b91c160">get</a>&lt; U &gt;())</td></tr>
<tr class="separator:a34780011ee13a3ede041ddcee288f484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb149366faaa55aa6bf1e510900353ea" id="r_aeb149366faaa55aa6bf1e510900353ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb149366faaa55aa6bf1e510900353ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aeb149366faaa55aa6bf1e510900353ea">detect_key_compare</a> = typename T::key_compare</td></tr>
<tr class="separator:aeb149366faaa55aa6bf1e510900353ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3e5af512080ec5b71496dde9e0651c" id="r_acf3e5af512080ec5b71496dde9e0651c"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:acf3e5af512080ec5b71496dde9e0651c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#acf3e5af512080ec5b71496dde9e0651c">actual_object_comparator_t</a> = typename <a class="el" href="structdetail_1_1actual__object__comparator.html">actual_object_comparator</a>&lt; BasicJsonType &gt;::type</td></tr>
<tr class="separator:acf3e5af512080ec5b71496dde9e0651c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f53d4fa21096275fc0e3016e27daf1" id="r_a70f53d4fa21096275fc0e3016e27daf1"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a70f53d4fa21096275fc0e3016e27daf1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a70f53d4fa21096275fc0e3016e27daf1">iterator_t</a> = <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__range.html">is_range</a>&lt; R &gt;::value, result_of_begin&lt; decltype(std::declval&lt; R &amp; &gt;())&gt; &gt;</td></tr>
<tr class="separator:a70f53d4fa21096275fc0e3016e27daf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2653c739e3ac41529a35735397b4f41" id="r_ac2653c739e3ac41529a35735397b4f41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2653c739e3ac41529a35735397b4f41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ac2653c739e3ac41529a35735397b4f41">range_value_t</a> = <a class="el" href="namespacedetail.html#a53f74b6382403d25215a9433897255b4">value_type_t</a>&lt; <a class="el" href="structdetail_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="namespacedetail.html#a70f53d4fa21096275fc0e3016e27daf1">iterator_t</a>&lt; T &gt; &gt; &gt;</td></tr>
<tr class="separator:ac2653c739e3ac41529a35735397b4f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d62ae589bb3ae01d156629c0b58b0f2" id="r_a6d62ae589bb3ae01d156629c0b58b0f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d62ae589bb3ae01d156629c0b58b0f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a6d62ae589bb3ae01d156629c0b58b0f2">is_json_pointer</a> = <a class="el" href="structdetail_1_1is__specialization__of.html">is_specialization_of</a>&lt;::nlohmann::json_pointer, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">uncvref_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a6d62ae589bb3ae01d156629c0b58b0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6a1fa89738d39f7f123db6bad96101" id="r_add6a1fa89738d39f7f123db6bad96101"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add6a1fa89738d39f7f123db6bad96101"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#add6a1fa89738d39f7f123db6bad96101">detect_is_transparent</a> = typename T::is_transparent</td></tr>
<tr class="separator:add6a1fa89738d39f7f123db6bad96101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d80ed747c2ea999c378519a7a6d6d31" id="r_a9d80ed747c2ea999c378519a7a6d6d31"><td class="memTemplParams" colspan="2">template&lt;typename Comparator , typename ObjectKeyType , typename KeyTypeCVRef , bool RequireTransparentComparator = true, bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType  = uncvref_t&lt;KeyTypeCVRef&gt;&gt; </td></tr>
<tr class="memitem:a9d80ed747c2ea999c378519a7a6d6d31"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a9d80ed747c2ea999c378519a7a6d6d31">is_usable_as_key_type</a> = typename std::conditional&lt; <a class="el" href="structdetail_1_1is__comparable.html">is_comparable</a>&lt; Comparator, ObjectKeyType, KeyTypeCVRef &gt;::value &amp;&amp;!(ExcludeObjectKeyType &amp;&amp;std::is_same&lt; KeyType, ObjectKeyType &gt;::value) &amp;&amp;(!RequireTransparentComparator||<a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt; <a class="el" href="namespacedetail.html#add6a1fa89738d39f7f123db6bad96101">detect_is_transparent</a>, Comparator &gt;::value) &amp;&amp;!<a class="el" href="namespacedetail.html#a6d62ae589bb3ae01d156629c0b58b0f2">is_json_pointer</a>&lt; KeyType &gt;::value, std::true_type, std::false_type &gt;::type</td></tr>
<tr class="separator:a9d80ed747c2ea999c378519a7a6d6d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f5970957ff03ced71ce77b9417b00" id="r_a394f5970957ff03ced71ce77b9417b00"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename KeyTypeCVRef , bool RequireTransparentComparator = true, bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType  = uncvref_t&lt;KeyTypeCVRef&gt;&gt; </td></tr>
<tr class="memitem:a394f5970957ff03ced71ce77b9417b00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">is_usable_as_basic_json_key_type</a> = typename std::conditional&lt; <a class="el" href="namespacedetail.html#a9d80ed747c2ea999c378519a7a6d6d31">is_usable_as_key_type</a>&lt; typename BasicJsonType::object_comparator_t, typename BasicJsonType::object_t::key_type, KeyTypeCVRef, RequireTransparentComparator, ExcludeObjectKeyType &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__json__iterator__of.html">is_json_iterator_of</a>&lt; BasicJsonType, KeyType &gt;::value, std::true_type, std::false_type &gt;::type</td></tr>
<tr class="separator:a394f5970957ff03ced71ce77b9417b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fd4ed53e2a6c71fe1fa557e1923b9f" id="r_ae8fd4ed53e2a6c71fe1fa557e1923b9f"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , typename KeyType &gt; </td></tr>
<tr class="memitem:ae8fd4ed53e2a6c71fe1fa557e1923b9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ae8fd4ed53e2a6c71fe1fa557e1923b9f">detect_erase_with_key_type</a> = decltype(std::declval&lt; ObjectType &amp; &gt;().erase(std::declval&lt; KeyType &gt;()))</td></tr>
<tr class="separator:ae8fd4ed53e2a6c71fe1fa557e1923b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4a9f5dc3f5e2b43c8dc87698d6d689" id="r_abd4a9f5dc3f5e2b43c8dc87698d6d689"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename KeyType &gt; </td></tr>
<tr class="memitem:abd4a9f5dc3f5e2b43c8dc87698d6d689"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#abd4a9f5dc3f5e2b43c8dc87698d6d689">has_erase_with_key_type</a> = typename std::conditional&lt; <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt; <a class="el" href="namespacedetail.html#ae8fd4ed53e2a6c71fe1fa557e1923b9f">detect_erase_with_key_type</a>, typename BasicJsonType::object_t, KeyType &gt;::value, std::true_type, std::false_type &gt;::type</td></tr>
<tr class="separator:abd4a9f5dc3f5e2b43c8dc87698d6d689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f25f590a08b4a0e4c26e515471003d" id="r_a76f25f590a08b4a0e4c26e515471003d"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a76f25f590a08b4a0e4c26e515471003d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a76f25f590a08b4a0e4c26e515471003d">all_integral</a> = <a class="el" href="structdetail_1_1conjunction.html">conjunction</a>&lt; std::is_integral&lt; Types &gt;... &gt;</td></tr>
<tr class="separator:a76f25f590a08b4a0e4c26e515471003d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78ba866159e98c93c50a9a1140901dc" id="r_ac78ba866159e98c93c50a9a1140901dc"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ac78ba866159e98c93c50a9a1140901dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ac78ba866159e98c93c50a9a1140901dc">all_signed</a> = <a class="el" href="structdetail_1_1conjunction.html">conjunction</a>&lt; std::is_signed&lt; Types &gt;... &gt;</td></tr>
<tr class="separator:ac78ba866159e98c93c50a9a1140901dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804e13d43be14f983b738e18f0bb8eb9" id="r_a804e13d43be14f983b738e18f0bb8eb9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a804e13d43be14f983b738e18f0bb8eb9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a804e13d43be14f983b738e18f0bb8eb9">all_unsigned</a> = <a class="el" href="structdetail_1_1conjunction.html">conjunction</a>&lt; std::is_unsigned&lt; Types &gt;... &gt;</td></tr>
<tr class="separator:a804e13d43be14f983b738e18f0bb8eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e73e1b9fba3c45b9ad1b0b7f4f1c9b" id="r_a91e73e1b9fba3c45b9ad1b0b7f4f1c9b"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a91e73e1b9fba3c45b9ad1b0b7f4f1c9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a91e73e1b9fba3c45b9ad1b0b7f4f1c9b">same_sign</a> = std::integral_constant&lt; bool, <a class="el" href="namespacedetail.html#ac78ba866159e98c93c50a9a1140901dc">all_signed</a>&lt; Types... &gt;::value||<a class="el" href="namespacedetail.html#a804e13d43be14f983b738e18f0bb8eb9">all_unsigned</a>&lt; Types... &gt;::value &gt;</td></tr>
<tr class="separator:a91e73e1b9fba3c45b9ad1b0b7f4f1c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80e4e59be493e62842fb40354351e8b" id="r_af80e4e59be493e62842fb40354351e8b"><td class="memTemplParams" colspan="2">template&lt;typename OfType , typename T &gt; </td></tr>
<tr class="memitem:af80e4e59be493e62842fb40354351e8b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#af80e4e59be493e62842fb40354351e8b">never_out_of_range</a> = std::integral_constant&lt; bool,(std::is_signed&lt; OfType &gt;::value &amp;&amp;(sizeof(T)&lt; sizeof(OfType)))||(<a class="el" href="namespacedetail.html#a91e73e1b9fba3c45b9ad1b0b7f4f1c9b">same_sign</a>&lt; OfType, T &gt;::value &amp;&amp;sizeof(OfType)==sizeof(T)) &gt;</td></tr>
<tr class="separator:af80e4e59be493e62842fb40354351e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867b6755c86931c5824f5c97cba3b470" id="r_a867b6755c86931c5824f5c97cba3b470"><td class="memTemplParams" colspan="2">template&lt;bool Value&gt; </td></tr>
<tr class="memitem:a867b6755c86931c5824f5c97cba3b470"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a867b6755c86931c5824f5c97cba3b470">bool_constant</a> = std::integral_constant&lt; bool, Value &gt;</td></tr>
<tr class="separator:a867b6755c86931c5824f5c97cba3b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d99cdff6fa6a48145e5f7209d60db5a" id="r_a9d99cdff6fa6a48145e5f7209d60db5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d99cdff6fa6a48145e5f7209d60db5a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a9d99cdff6fa6a48145e5f7209d60db5a">is_c_string_uncvref</a> = <a class="el" href="structdetail_1_1is__c__string.html">is_c_string</a>&lt; <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">uncvref_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a9d99cdff6fa6a48145e5f7209d60db5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4c26a378982200b0f5e74a896366da" id="r_acf4c26a378982200b0f5e74a896366da"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename Arg &gt; </td></tr>
<tr class="memitem:acf4c26a378982200b0f5e74a896366da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#acf4c26a378982200b0f5e74a896366da">string_can_append</a> = decltype(std::declval&lt; StringType &amp; &gt;().append(std::declval&lt; Arg &amp;&amp; &gt;()))</td></tr>
<tr class="separator:acf4c26a378982200b0f5e74a896366da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4e2beed41963eb3fc4a270821633f3" id="r_afa4e2beed41963eb3fc4a270821633f3"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename Arg &gt; </td></tr>
<tr class="memitem:afa4e2beed41963eb3fc4a270821633f3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#afa4e2beed41963eb3fc4a270821633f3">detect_string_can_append</a> = <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt; <a class="el" href="namespacedetail.html#acf4c26a378982200b0f5e74a896366da">string_can_append</a>, StringType, Arg &gt;</td></tr>
<tr class="separator:afa4e2beed41963eb3fc4a270821633f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c834c5cfd6433e7d65371d1bc99972" id="r_a19c834c5cfd6433e7d65371d1bc99972"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename Arg &gt; </td></tr>
<tr class="memitem:a19c834c5cfd6433e7d65371d1bc99972"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a19c834c5cfd6433e7d65371d1bc99972">string_can_append_op</a> = decltype(std::declval&lt; StringType &amp; &gt;()+=std::declval&lt; Arg &amp;&amp; &gt;())</td></tr>
<tr class="separator:a19c834c5cfd6433e7d65371d1bc99972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5c0042966002d3d0a653b504cf95da" id="r_a4c5c0042966002d3d0a653b504cf95da"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename Arg &gt; </td></tr>
<tr class="memitem:a4c5c0042966002d3d0a653b504cf95da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a4c5c0042966002d3d0a653b504cf95da">detect_string_can_append_op</a> = <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt; <a class="el" href="namespacedetail.html#a19c834c5cfd6433e7d65371d1bc99972">string_can_append_op</a>, StringType, Arg &gt;</td></tr>
<tr class="separator:a4c5c0042966002d3d0a653b504cf95da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6d98622b8133a6c4b873556cb55a9a" id="r_a9e6d98622b8133a6c4b873556cb55a9a"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename Arg &gt; </td></tr>
<tr class="memitem:a9e6d98622b8133a6c4b873556cb55a9a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a9e6d98622b8133a6c4b873556cb55a9a">string_can_append_iter</a> = decltype(std::declval&lt; StringType &amp; &gt;().append(std::declval&lt; const Arg &amp; &gt;().begin(), std::declval&lt; const Arg &amp; &gt;().end()))</td></tr>
<tr class="separator:a9e6d98622b8133a6c4b873556cb55a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2fa7cb837caf838593444fe0d910b7" id="r_a2a2fa7cb837caf838593444fe0d910b7"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename Arg &gt; </td></tr>
<tr class="memitem:a2a2fa7cb837caf838593444fe0d910b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a2a2fa7cb837caf838593444fe0d910b7">detect_string_can_append_iter</a> = <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt; <a class="el" href="namespacedetail.html#a9e6d98622b8133a6c4b873556cb55a9a">string_can_append_iter</a>, StringType, Arg &gt;</td></tr>
<tr class="separator:a2a2fa7cb837caf838593444fe0d910b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2aa53ac9a71b89c3d6931de1d8fab6" id="r_aed2aa53ac9a71b89c3d6931de1d8fab6"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename Arg &gt; </td></tr>
<tr class="memitem:aed2aa53ac9a71b89c3d6931de1d8fab6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aed2aa53ac9a71b89c3d6931de1d8fab6">string_can_append_data</a> = decltype(std::declval&lt; StringType &amp; &gt;().append(std::declval&lt; const Arg &amp; &gt;().data(), std::declval&lt; const Arg &amp; &gt;().size()))</td></tr>
<tr class="separator:aed2aa53ac9a71b89c3d6931de1d8fab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6299248749609c15beeb2804d3dd8c76" id="r_a6299248749609c15beeb2804d3dd8c76"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename Arg &gt; </td></tr>
<tr class="memitem:a6299248749609c15beeb2804d3dd8c76"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a6299248749609c15beeb2804d3dd8c76">detect_string_can_append_data</a> = <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt; <a class="el" href="namespacedetail.html#aed2aa53ac9a71b89c3d6931de1d8fab6">string_can_append_data</a>, StringType, Arg &gt;</td></tr>
<tr class="separator:a6299248749609c15beeb2804d3dd8c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ea2ae325b8654ea5ce36e2c5043f0a" id="r_ae0ea2ae325b8654ea5ce36e2c5043f0a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae0ea2ae325b8654ea5ce36e2c5043f0a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ae0ea2ae325b8654ea5ce36e2c5043f0a">json_base_class</a> = typename std::conditional&lt; std::is_same&lt; T, void &gt;::value, <a class="el" href="structdetail_1_1json__default__base.html">json_default_base</a>, T &gt;::type</td></tr>
<tr class="separator:ae0ea2ae325b8654ea5ce36e2c5043f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a917c3efabea8a20dc72d9ae2c673d632" id="r_a917c3efabea8a20dc72d9ae2c673d632"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd">null</a>
, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666">object</a>
, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5">array</a>
, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21">string</a>
, <br />
&#160;&#160;<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27">boolean</a>
, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc">number_integer</a>
, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e">number_unsigned</a>
, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef">number_float</a>
, <br />
&#160;&#160;<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20">binary</a>
, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46">discarded</a>
<br />
 }</td></tr>
<tr class="memdesc:a917c3efabea8a20dc72d9ae2c673d632"><td class="mdescLeft">&#160;</td><td class="mdescRight">the JSON type enumeration  <a href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">More...</a><br /></td></tr>
<tr class="separator:a917c3efabea8a20dc72d9ae2c673d632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c070b2bf3d61e3d8b8013f6fb18d592" id="r_a7c070b2bf3d61e3d8b8013f6fb18d592"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> { <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">error</a>
, <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592a567bc1d268f135496de3d5b946b691f3">ignore</a>
, <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592a8cd892b7b97ef9489ae4479d3f4ef0fc">store</a>
 }</td></tr>
<tr class="memdesc:a7c070b2bf3d61e3d8b8013f6fb18d592"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat CBOR tags  <a href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">More...</a><br /></td></tr>
<tr class="separator:a7c070b2bf3d61e3d8b8013f6fb18d592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7cfa1fd8fa706ff4392bff9d1a8298" id="r_abe7cfa1fd8fa706ff4392bff9d1a8298"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a> { <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792">strict</a>
, <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298a9dde360102c103867bd2f45872f1129c">replace</a>
, <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298a567bc1d268f135496de3d5b946b691f3">ignore</a>
 }</td></tr>
<tr class="memdesc:abe7cfa1fd8fa706ff4392bff9d1a8298"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat decoding errors  <a href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">More...</a><br /></td></tr>
<tr class="separator:abe7cfa1fd8fa706ff4392bff9d1a8298"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aac7ca91589afb0bad68baec5949daaa2" id="r_aac7ca91589afb0bad68baec5949daaa2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aac7ca91589afb0bad68baec5949daaa2">operator&lt;</a> (const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> lhs, const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> rhs) noexcept</td></tr>
<tr class="memdesc:aac7ca91589afb0bad68baec5949daaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator for JSON types  <br /></td></tr>
<tr class="separator:aac7ca91589afb0bad68baec5949daaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd295e53b1dd4f46e235e6afee26d5e" id="r_a6fd295e53b1dd4f46e235e6afee26d5e"><td class="memTemplParams" colspan="2">template&lt;typename StringType &gt; </td></tr>
<tr class="memitem:a6fd295e53b1dd4f46e235e6afee26d5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a6fd295e53b1dd4f46e235e6afee26d5e">replace_substring</a> (StringType &amp;s, const StringType &amp;f, const StringType &amp;t)</td></tr>
<tr class="memdesc:a6fd295e53b1dd4f46e235e6afee26d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace all occurrences of a substring by another string  <br /></td></tr>
<tr class="separator:a6fd295e53b1dd4f46e235e6afee26d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9ce4740e0b45d33129e2c8e53a0a8" id="r_af2a9ce4740e0b45d33129e2c8e53a0a8"><td class="memTemplParams" colspan="2">template&lt;typename StringType &gt; </td></tr>
<tr class="memitem:af2a9ce4740e0b45d33129e2c8e53a0a8"><td class="memTemplItemLeft" align="right" valign="top">StringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#af2a9ce4740e0b45d33129e2c8e53a0a8">escape</a> (StringType s)</td></tr>
<tr class="memdesc:af2a9ce4740e0b45d33129e2c8e53a0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">string escaping as described in RFC 6901 (Sect. 4)  <br /></td></tr>
<tr class="separator:af2a9ce4740e0b45d33129e2c8e53a0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e971234e72db1e314aa87298e84d1d0" id="r_a0e971234e72db1e314aa87298e84d1d0"><td class="memTemplParams" colspan="2">template&lt;typename StringType &gt; </td></tr>
<tr class="memitem:a0e971234e72db1e314aa87298e84d1d0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a0e971234e72db1e314aa87298e84d1d0">unescape</a> (StringType &amp;s)</td></tr>
<tr class="memdesc:a0e971234e72db1e314aa87298e84d1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">string unescaping as described in RFC 6901 (Sect. 4)  <br /></td></tr>
<tr class="separator:a0e971234e72db1e314aa87298e84d1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346dced829a9a2b98a722a31c62b3f7a" id="r_a346dced829a9a2b98a722a31c62b3f7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a346dced829a9a2b98a722a31c62b3f7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, sizeof...(Args)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a346dced829a9a2b98a722a31c62b3f7a">make_array</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a346dced829a9a2b98a722a31c62b3f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d17f1d261bd9fec64c08343c9f809fc" id="r_a5d17f1d261bd9fec64c08343c9f809fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; !std::is_same&lt; T, U &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5d17f1d261bd9fec64c08343c9f809fc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a5d17f1d261bd9fec64c08343c9f809fc">conditional_static_cast</a> (U value)</td></tr>
<tr class="separator:a5d17f1d261bd9fec64c08343c9f809fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7a4119c6c8e86cef8f1c904c8bf040" id="r_a8e7a4119c6c8e86cef8f1c904c8bf040"><td class="memTemplParams" colspan="2">template&lt;typename OfType , typename T &gt; </td></tr>
<tr class="memitem:a8e7a4119c6c8e86cef8f1c904c8bf040"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a8e7a4119c6c8e86cef8f1c904c8bf040">value_in_range_of</a> (T val)</td></tr>
<tr class="separator:a8e7a4119c6c8e86cef8f1c904c8bf040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac185140ed8c8fcc07a302a890b714b0d" id="r_ac185140ed8c8fcc07a302a890b714b0d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ac185140ed8c8fcc07a302a890b714b0d">concat_length</a> ()</td></tr>
<tr class="separator:ac185140ed8c8fcc07a302a890b714b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d26947197a0f2d23110a4f40bd90d85" id="r_a5d26947197a0f2d23110a4f40bd90d85"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5d26947197a0f2d23110a4f40bd90d85"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a5d26947197a0f2d23110a4f40bd90d85">concat_length</a> (const char *cstr, const Args &amp;... rest)</td></tr>
<tr class="separator:a5d26947197a0f2d23110a4f40bd90d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd92967d2de985b74ce05092fc21680" id="r_a3cd92967d2de985b74ce05092fc21680"><td class="memTemplParams" colspan="2">template&lt;typename StringType , typename... Args&gt; </td></tr>
<tr class="memitem:a3cd92967d2de985b74ce05092fc21680"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a3cd92967d2de985b74ce05092fc21680">concat_length</a> (const StringType &amp;str, const Args &amp;... rest)</td></tr>
<tr class="separator:a3cd92967d2de985b74ce05092fc21680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f189c556ba621b4bbb57fe03cd4800" id="r_aa5f189c556ba621b4bbb57fe03cd4800"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa5f189c556ba621b4bbb57fe03cd4800"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aa5f189c556ba621b4bbb57fe03cd4800">concat_length</a> (const char, const Args &amp;... rest)</td></tr>
<tr class="separator:aa5f189c556ba621b4bbb57fe03cd4800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f967b745cf8df11ba9d59f93d97753" id="r_a89f967b745cf8df11ba9d59f93d97753"><td class="memTemplParams" colspan="2">template&lt;typename OutStringType &gt; </td></tr>
<tr class="memitem:a89f967b745cf8df11ba9d59f93d97753"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a89f967b745cf8df11ba9d59f93d97753">concat_into</a> (OutStringType &amp;)</td></tr>
<tr class="separator:a89f967b745cf8df11ba9d59f93d97753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16fc2d4a149a0e3ac68ceb98b153815" id="r_aa16fc2d4a149a0e3ac68ceb98b153815"><td class="memTemplParams" colspan="2">template&lt;typename OutStringType , typename Arg , typename... Args, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; !<a class="el" href="namespacedetail.html#afa4e2beed41963eb3fc4a270821633f3">detect_string_can_append</a>&lt; OutStringType, Arg &gt;::value &amp;&amp;<a class="el" href="namespacedetail.html#a4c5c0042966002d3d0a653b504cf95da">detect_string_can_append_op</a>&lt; OutStringType, Arg &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa16fc2d4a149a0e3ac68ceb98b153815"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aa16fc2d4a149a0e3ac68ceb98b153815">concat_into</a> (OutStringType &amp;out, Arg &amp;&amp;arg, Args &amp;&amp;... rest)</td></tr>
<tr class="separator:aa16fc2d4a149a0e3ac68ceb98b153815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78434fad7c03e66afdd06a6df628315a" id="r_a78434fad7c03e66afdd06a6df628315a"><td class="memTemplParams" colspan="2">template&lt;typename OutStringType , typename Arg , typename... Args, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; !<a class="el" href="namespacedetail.html#afa4e2beed41963eb3fc4a270821633f3">detect_string_can_append</a>&lt; OutStringType, Arg &gt;::value &amp;&amp;!<a class="el" href="namespacedetail.html#a4c5c0042966002d3d0a653b504cf95da">detect_string_can_append_op</a>&lt; OutStringType, Arg &gt;::value &amp;&amp;<a class="el" href="namespacedetail.html#a2a2fa7cb837caf838593444fe0d910b7">detect_string_can_append_iter</a>&lt; OutStringType, Arg &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a78434fad7c03e66afdd06a6df628315a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a78434fad7c03e66afdd06a6df628315a">concat_into</a> (OutStringType &amp;out, const Arg &amp;arg, Args &amp;&amp;... rest)</td></tr>
<tr class="separator:a78434fad7c03e66afdd06a6df628315a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266fb3d4bf633ad6c506434cc91164da" id="r_a266fb3d4bf633ad6c506434cc91164da"><td class="memTemplParams" colspan="2">template&lt;typename OutStringType  = std::string, typename... Args&gt; </td></tr>
<tr class="memitem:a266fb3d4bf633ad6c506434cc91164da"><td class="memTemplItemLeft" align="right" valign="top">OutStringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a266fb3d4bf633ad6c506434cc91164da">concat</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a266fb3d4bf633ad6c506434cc91164da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75fd8de21cdb8a0ed835b94aa02e5da" id="r_af75fd8de21cdb8a0ed835b94aa02e5da"><td class="memTemplParams" colspan="2">template&lt;typename string_type &gt; </td></tr>
<tr class="memitem:af75fd8de21cdb8a0ed835b94aa02e5da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#af75fd8de21cdb8a0ed835b94aa02e5da">int_to_string</a> (string_type &amp;target, std::size_t value)</td></tr>
<tr class="separator:af75fd8de21cdb8a0ed835b94aa02e5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7116703ea757fe9821bf2e903b91c160" id="r_a7116703ea757fe9821bf2e903b91c160"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename IteratorType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; N==0, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7116703ea757fe9821bf2e903b91c160"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a7116703ea757fe9821bf2e903b91c160">get</a> (const nlohmann::detail::iteration_proxy_value&lt; IteratorType &gt; &amp;i) -&gt; decltype(i.key())</td></tr>
<tr class="separator:a7116703ea757fe9821bf2e903b91c160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdf2e4c8f09d5acaa2841358db51f82" id="r_acfdf2e4c8f09d5acaa2841358db51f82"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename T , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_same&lt; T, typename BasicJsonType::boolean_t &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acfdf2e4c8f09d5acaa2841358db51f82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#acfdf2e4c8f09d5acaa2841358db51f82">to_json</a> (BasicJsonType &amp;j, T b) noexcept</td></tr>
<tr class="separator:acfdf2e4c8f09d5acaa2841358db51f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432a72eacdbf2e603aadbef62b0693e5" id="r_a432a72eacdbf2e603aadbef62b0693e5"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename BoolRef , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt;((std::is_same&lt; std::vector&lt; bool &gt;::reference, BoolRef &gt;::value &amp;&amp;!std::is_same&lt; std::vector&lt; bool &gt;::reference, typename BasicJsonType::boolean_t &amp; &gt;::value)||(std::is_same&lt; std::vector&lt; bool &gt;::const_reference, BoolRef &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; std::vector&lt; bool &gt;::const_reference &gt;, typename BasicJsonType::boolean_t &gt;::value)) &amp;&amp;std::is_convertible&lt; const BoolRef &amp;, typename BasicJsonType::boolean_t &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a432a72eacdbf2e603aadbef62b0693e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a432a72eacdbf2e603aadbef62b0693e5">to_json</a> (BasicJsonType &amp;j, const BoolRef &amp;b) noexcept</td></tr>
<tr class="separator:a432a72eacdbf2e603aadbef62b0693e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8440d5ee74cd66effc302294a0f03a" id="r_a5c8440d5ee74cd66effc302294a0f03a"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename CompatibleString , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_constructible&lt; typename BasicJsonType::string_t, CompatibleString &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5c8440d5ee74cd66effc302294a0f03a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a5c8440d5ee74cd66effc302294a0f03a">to_json</a> (BasicJsonType &amp;j, const CompatibleString &amp;s)</td></tr>
<tr class="separator:a5c8440d5ee74cd66effc302294a0f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efa05c0a1af490d3cd2244ab1ec2935" id="r_a4efa05c0a1af490d3cd2244ab1ec2935"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a4efa05c0a1af490d3cd2244ab1ec2935"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a4efa05c0a1af490d3cd2244ab1ec2935">to_json</a> (BasicJsonType &amp;j, typename BasicJsonType::string_t &amp;&amp;s)</td></tr>
<tr class="separator:a4efa05c0a1af490d3cd2244ab1ec2935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd79e26a03ad0f6f014acde6ca955ab" id="r_a0fd79e26a03ad0f6f014acde6ca955ab"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename FloatType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_floating_point&lt; FloatType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0fd79e26a03ad0f6f014acde6ca955ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a0fd79e26a03ad0f6f014acde6ca955ab">to_json</a> (BasicJsonType &amp;j, FloatType val) noexcept</td></tr>
<tr class="separator:a0fd79e26a03ad0f6f014acde6ca955ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4eec865929224a2edcdd86e0e2f5381" id="r_af4eec865929224a2edcdd86e0e2f5381"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename CompatibleNumberUnsignedType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__compatible__integer__type.html">is_compatible_integer_type</a>&lt; typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af4eec865929224a2edcdd86e0e2f5381"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#af4eec865929224a2edcdd86e0e2f5381">to_json</a> (BasicJsonType &amp;j, CompatibleNumberUnsignedType val) noexcept</td></tr>
<tr class="separator:af4eec865929224a2edcdd86e0e2f5381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca950b6f8e111cbf473fa0a30b4118a9" id="r_aca950b6f8e111cbf473fa0a30b4118a9"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename CompatibleNumberIntegerType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__compatible__integer__type.html">is_compatible_integer_type</a>&lt; typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aca950b6f8e111cbf473fa0a30b4118a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aca950b6f8e111cbf473fa0a30b4118a9">to_json</a> (BasicJsonType &amp;j, CompatibleNumberIntegerType val) noexcept</td></tr>
<tr class="separator:aca950b6f8e111cbf473fa0a30b4118a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa73b51ab32301503f808871a7d1130" id="r_a0aa73b51ab32301503f808871a7d1130"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename EnumType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_enum&lt; EnumType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0aa73b51ab32301503f808871a7d1130"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a0aa73b51ab32301503f808871a7d1130">to_json</a> (BasicJsonType &amp;j, EnumType e) noexcept</td></tr>
<tr class="separator:a0aa73b51ab32301503f808871a7d1130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898665fe3505e4124ee130ac40b5f7c2" id="r_a898665fe3505e4124ee130ac40b5f7c2"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a898665fe3505e4124ee130ac40b5f7c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a898665fe3505e4124ee130ac40b5f7c2">to_json</a> (BasicJsonType &amp;j, const std::vector&lt; bool &gt; &amp;e)</td></tr>
<tr class="separator:a898665fe3505e4124ee130ac40b5f7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13eaa461d3df66f08b281ed8ef67443d" id="r_a13eaa461d3df66f08b281ed8ef67443d"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename CompatibleArrayType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__compatible__array__type.html">is_compatible_array_type</a>&lt; BasicJsonType, CompatibleArrayType &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__compatible__object__type.html">is_compatible_object_type</a>&lt; BasicJsonType, CompatibleArrayType &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__compatible__string__type.html">is_compatible_string_type</a>&lt; BasicJsonType, CompatibleArrayType &gt;::value &amp;&amp;!std::is_same&lt; typename BasicJsonType::binary_t, CompatibleArrayType &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__basic__json.html">is_basic_json</a>&lt; CompatibleArrayType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a13eaa461d3df66f08b281ed8ef67443d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a13eaa461d3df66f08b281ed8ef67443d">to_json</a> (BasicJsonType &amp;j, const CompatibleArrayType &amp;arr)</td></tr>
<tr class="separator:a13eaa461d3df66f08b281ed8ef67443d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4c34558512e0288775fefb01900d24" id="r_aac4c34558512e0288775fefb01900d24"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:aac4c34558512e0288775fefb01900d24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aac4c34558512e0288775fefb01900d24">to_json</a> (BasicJsonType &amp;j, const typename BasicJsonType::binary_t &amp;bin)</td></tr>
<tr class="separator:aac4c34558512e0288775fefb01900d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71164c6a1be656ae46c8a48a9f4f024f" id="r_a71164c6a1be656ae46c8a48a9f4f024f"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename T , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_convertible&lt; T, BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a71164c6a1be656ae46c8a48a9f4f024f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a71164c6a1be656ae46c8a48a9f4f024f">to_json</a> (BasicJsonType &amp;j, const std::valarray&lt; T &gt; &amp;arr)</td></tr>
<tr class="separator:a71164c6a1be656ae46c8a48a9f4f024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee383505e04bd7c68d4a288870147ff4" id="r_aee383505e04bd7c68d4a288870147ff4"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:aee383505e04bd7c68d4a288870147ff4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#aee383505e04bd7c68d4a288870147ff4">to_json</a> (BasicJsonType &amp;j, typename BasicJsonType::array_t &amp;&amp;arr)</td></tr>
<tr class="separator:aee383505e04bd7c68d4a288870147ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ddcd90b4d42832abc02eb516c4d99" id="r_a210ddcd90b4d42832abc02eb516c4d99"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename CompatibleObjectType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__compatible__object__type.html">is_compatible_object_type</a>&lt; BasicJsonType, CompatibleObjectType &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__basic__json.html">is_basic_json</a>&lt; CompatibleObjectType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a210ddcd90b4d42832abc02eb516c4d99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a210ddcd90b4d42832abc02eb516c4d99">to_json</a> (BasicJsonType &amp;j, const CompatibleObjectType &amp;obj)</td></tr>
<tr class="separator:a210ddcd90b4d42832abc02eb516c4d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b6774b5ab06f17f77c683d85f0b0b2" id="r_a48b6774b5ab06f17f77c683d85f0b0b2"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a48b6774b5ab06f17f77c683d85f0b0b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a48b6774b5ab06f17f77c683d85f0b0b2">to_json</a> (BasicJsonType &amp;j, typename BasicJsonType::object_t &amp;&amp;obj)</td></tr>
<tr class="separator:a48b6774b5ab06f17f77c683d85f0b0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120fee99373c660eb270811fd26226c8" id="r_a120fee99373c660eb270811fd26226c8"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename T , std::size_t N, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; !std::is_constructible&lt; typename BasicJsonType::string_t, const T(&amp;)[N]&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a120fee99373c660eb270811fd26226c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a120fee99373c660eb270811fd26226c8">to_json</a> (BasicJsonType &amp;j, const T(&amp;arr)[N])</td></tr>
<tr class="separator:a120fee99373c660eb270811fd26226c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7a3840a7af072111b938aafefa4bef" id="r_ade7a3840a7af072111b938aafefa4bef"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename T1 , typename T2 , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_constructible&lt; BasicJsonType, T1 &gt;::value &amp;&amp;std::is_constructible&lt; BasicJsonType, T2 &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ade7a3840a7af072111b938aafefa4bef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#ade7a3840a7af072111b938aafefa4bef">to_json</a> (BasicJsonType &amp;j, const std::pair&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="separator:ade7a3840a7af072111b938aafefa4bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5949a32eedf94fb0b98fd189fda0d6" id="r_a3f5949a32eedf94fb0b98fd189fda0d6"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename T , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_same&lt; T, <a class="el" href="classdetail_1_1iteration__proxy__value.html">iteration_proxy_value</a>&lt; typename BasicJsonType::iterator &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3f5949a32eedf94fb0b98fd189fda0d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a3f5949a32eedf94fb0b98fd189fda0d6">to_json</a> (BasicJsonType &amp;j, const T &amp;b)</td></tr>
<tr class="separator:a3f5949a32eedf94fb0b98fd189fda0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4851287a8b8b21ca8605d31ca446ea" id="r_a0d4851287a8b8b21ca8605d31ca446ea"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename Tuple , std::size_t... Idx&gt; </td></tr>
<tr class="memitem:a0d4851287a8b8b21ca8605d31ca446ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a0d4851287a8b8b21ca8605d31ca446ea">to_json_tuple_impl</a> (BasicJsonType &amp;j, const Tuple &amp;t, <a class="el" href="namespacedetail.html#a4e6f1f2e94159041593901afc8f0c9b0">index_sequence</a>&lt; Idx... &gt;)</td></tr>
<tr class="separator:a0d4851287a8b8b21ca8605d31ca446ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6920228c2b39db99481d6952ca1add" id="r_a9a6920228c2b39db99481d6952ca1add"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetail.html#a9a6920228c2b39db99481d6952ca1add">little_endianness</a> (int num=1) noexcept</td></tr>
<tr class="memdesc:a9a6920228c2b39db99481d6952ca1add"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine system byte order  <br /></td></tr>
<tr class="separator:a9a6920228c2b39db99481d6952ca1add"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>detail namespace with internal helper functions </p>
<p>This namespace collects functions that should not be exposed, implementations of some <a class="el" href="classbasic__json.html">basic_json</a> methods, and meta-programming helpers.</p>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="acf3e5af512080ec5b71496dde9e0651c" name="acf3e5af512080ec5b71496dde9e0651c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3e5af512080ec5b71496dde9e0651c">&#9670;&#160;</a></span>actual_object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#acf3e5af512080ec5b71496dde9e0651c">detail::actual_object_comparator_t</a> = typedef typename <a class="el" href="structdetail_1_1actual__object__comparator.html">actual_object_comparator</a>&lt;BasicJsonType&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76f25f590a08b4a0e4c26e515471003d" name="a76f25f590a08b4a0e4c26e515471003d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f25f590a08b4a0e4c26e515471003d">&#9670;&#160;</a></span>all_integral</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a76f25f590a08b4a0e4c26e515471003d">detail::all_integral</a> = typedef <a class="el" href="structdetail_1_1conjunction.html">conjunction</a>&lt;std::is_integral&lt;Types&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac78ba866159e98c93c50a9a1140901dc" name="ac78ba866159e98c93c50a9a1140901dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78ba866159e98c93c50a9a1140901dc">&#9670;&#160;</a></span>all_signed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#ac78ba866159e98c93c50a9a1140901dc">detail::all_signed</a> = typedef <a class="el" href="structdetail_1_1conjunction.html">conjunction</a>&lt;std::is_signed&lt;Types&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a804e13d43be14f983b738e18f0bb8eb9" name="a804e13d43be14f983b738e18f0bb8eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804e13d43be14f983b738e18f0bb8eb9">&#9670;&#160;</a></span>all_unsigned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a804e13d43be14f983b738e18f0bb8eb9">detail::all_unsigned</a> = typedef <a class="el" href="structdetail_1_1conjunction.html">conjunction</a>&lt;std::is_unsigned&lt;Types&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a867b6755c86931c5824f5c97cba3b470" name="a867b6755c86931c5824f5c97cba3b470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867b6755c86931c5824f5c97cba3b470">&#9670;&#160;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a867b6755c86931c5824f5c97cba3b470">detail::bool_constant</a> = typedef std::integral_constant&lt;bool, Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8fd4ed53e2a6c71fe1fa557e1923b9f" name="ae8fd4ed53e2a6c71fe1fa557e1923b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fd4ed53e2a6c71fe1fa557e1923b9f">&#9670;&#160;</a></span>detect_erase_with_key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#ae8fd4ed53e2a6c71fe1fa557e1923b9f">detail::detect_erase_with_key_type</a> = typedef decltype(std::declval&lt;ObjectType&amp;&gt;().erase(std::declval&lt;KeyType&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add6a1fa89738d39f7f123db6bad96101" name="add6a1fa89738d39f7f123db6bad96101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6a1fa89738d39f7f123db6bad96101">&#9670;&#160;</a></span>detect_is_transparent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#add6a1fa89738d39f7f123db6bad96101">detail::detect_is_transparent</a> = typedef typename T::is_transparent</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb149366faaa55aa6bf1e510900353ea" name="aeb149366faaa55aa6bf1e510900353ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb149366faaa55aa6bf1e510900353ea">&#9670;&#160;</a></span>detect_key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#aeb149366faaa55aa6bf1e510900353ea">detail::detect_key_compare</a> = typedef typename T::key_compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa4e2beed41963eb3fc4a270821633f3" name="afa4e2beed41963eb3fc4a270821633f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4e2beed41963eb3fc4a270821633f3">&#9670;&#160;</a></span>detect_string_can_append</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#afa4e2beed41963eb3fc4a270821633f3">detail::detect_string_can_append</a> = typedef <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt;<a class="el" href="namespacedetail.html#acf4c26a378982200b0f5e74a896366da">string_can_append</a>, StringType, Arg&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6299248749609c15beeb2804d3dd8c76" name="a6299248749609c15beeb2804d3dd8c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6299248749609c15beeb2804d3dd8c76">&#9670;&#160;</a></span>detect_string_can_append_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a6299248749609c15beeb2804d3dd8c76">detail::detect_string_can_append_data</a> = typedef <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt;<a class="el" href="namespacedetail.html#aed2aa53ac9a71b89c3d6931de1d8fab6">string_can_append_data</a>, StringType, Arg&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a2fa7cb837caf838593444fe0d910b7" name="a2a2fa7cb837caf838593444fe0d910b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2fa7cb837caf838593444fe0d910b7">&#9670;&#160;</a></span>detect_string_can_append_iter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a2a2fa7cb837caf838593444fe0d910b7">detail::detect_string_can_append_iter</a> = typedef <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt;<a class="el" href="namespacedetail.html#a9e6d98622b8133a6c4b873556cb55a9a">string_can_append_iter</a>, StringType, Arg&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c5c0042966002d3d0a653b504cf95da" name="a4c5c0042966002d3d0a653b504cf95da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5c0042966002d3d0a653b504cf95da">&#9670;&#160;</a></span>detect_string_can_append_op</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a4c5c0042966002d3d0a653b504cf95da">detail::detect_string_can_append_op</a> = typedef <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a>&lt;<a class="el" href="namespacedetail.html#a19c834c5cfd6433e7d65371d1bc99972">string_can_append_op</a>, StringType, Arg&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f58658f7add3da8b8b976f181fa38e0" name="a7f58658f7add3da8b8b976f181fa38e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f58658f7add3da8b8b976f181fa38e0">&#9670;&#160;</a></span>detected_or</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a7f58658f7add3da8b8b976f181fa38e0">detail::detected_or</a> = typedef <a class="el" href="structdetail_1_1detector.html">detector</a>&lt;Default, void, Op, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c8c357df0fc3008a19bf4dca3bedcc9" name="a7c8c357df0fc3008a19bf4dca3bedcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8c357df0fc3008a19bf4dca3bedcc9">&#9670;&#160;</a></span>detected_or_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a7c8c357df0fc3008a19bf4dca3bedcc9">detail::detected_or_t</a> = typedef typename <a class="el" href="namespacedetail.html#a7f58658f7add3da8b8b976f181fa38e0">detected_or</a>&lt;Default, Op, Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d7d25c4bee06898292dff4eb4e381bf" name="a9d7d25c4bee06898292dff4eb4e381bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7d25c4bee06898292dff4eb4e381bf">&#9670;&#160;</a></span>detected_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class Op, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a9d7d25c4bee06898292dff4eb4e381bf">detail::detected_t</a> = typedef typename <a class="el" href="structdetail_1_1detector.html">detector</a>&lt;<a class="el" href="structdetail_1_1nonesuch.html">nonesuch</a>, void, Op, Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4e225ffcce63aef0a259e2c6bd839c1" name="ad4e225ffcce63aef0a259e2c6bd839c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e225ffcce63aef0a259e2c6bd839c1">&#9670;&#160;</a></span>difference_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#ad4e225ffcce63aef0a259e2c6bd839c1">detail::difference_type_t</a> = typedef typename T::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66bbcd629c83a87ba9cbc72a675cf84a" name="a66bbcd629c83a87ba9cbc72a675cf84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bbcd629c83a87ba9cbc72a675cf84a">&#9670;&#160;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">detail::enable_if_t</a> = typedef typename std::enable_if&lt;B, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d0993334c14a7e8055e1ec5ff237133" name="a7d0993334c14a7e8055e1ec5ff237133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0993334c14a7e8055e1ec5ff237133">&#9670;&#160;</a></span>from_json_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a7d0993334c14a7e8055e1ec5ff237133">detail::from_json_function</a> = typedef decltype(T::from_json(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34780011ee13a3ede041ddcee288f484" name="a34780011ee13a3ede041ddcee288f484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34780011ee13a3ede041ddcee288f484">&#9670;&#160;</a></span>get_template_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a34780011ee13a3ede041ddcee288f484">detail::get_template_function</a> = typedef decltype(std::declval&lt;T&gt;().template <a class="el" href="namespacedetail.html#a7116703ea757fe9821bf2e903b91c160">get</a>&lt;U&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd4a9f5dc3f5e2b43c8dc87698d6d689" name="abd4a9f5dc3f5e2b43c8dc87698d6d689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4a9f5dc3f5e2b43c8dc87698d6d689">&#9670;&#160;</a></span>has_erase_with_key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#abd4a9f5dc3f5e2b43c8dc87698d6d689">detail::has_erase_with_key_type</a> = typedef typename std::conditional &lt; <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a> &lt; <a class="el" href="namespacedetail.html#ae8fd4ed53e2a6c71fe1fa557e1923b9f">detect_erase_with_key_type</a>, typename BasicJsonType::object_t, KeyType &gt;::value, std::true_type, std::false_type &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e6f1f2e94159041593901afc8f0c9b0" name="a4e6f1f2e94159041593901afc8f0c9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6f1f2e94159041593901afc8f0c9b0">&#9670;&#160;</a></span>index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... Ints&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a4e6f1f2e94159041593901afc8f0c9b0">detail::index_sequence</a> = typedef <a class="el" href="structdetail_1_1integer__sequence.html">integer_sequence</a>&lt;size_t, Ints...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2cab3320b7c6d98af3ddf06c1a6b112" name="ad2cab3320b7c6d98af3ddf06c1a6b112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cab3320b7c6d98af3ddf06c1a6b112">&#9670;&#160;</a></span>index_sequence_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#ad2cab3320b7c6d98af3ddf06c1a6b112">detail::index_sequence_for</a> = typedef <a class="el" href="namespacedetail.html#a82dd889f447e7a1383b8757be27f66e9">make_index_sequence</a>&lt;sizeof...(Ts)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d99cdff6fa6a48145e5f7209d60db5a" name="a9d99cdff6fa6a48145e5f7209d60db5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d99cdff6fa6a48145e5f7209d60db5a">&#9670;&#160;</a></span>is_c_string_uncvref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a9d99cdff6fa6a48145e5f7209d60db5a">detail::is_c_string_uncvref</a> = typedef <a class="el" href="structdetail_1_1is__c__string.html">is_c_string</a>&lt;<a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">uncvref_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af040ff7b29d4c7ebd4dc6062bb3db008" name="af040ff7b29d4c7ebd4dc6062bb3db008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af040ff7b29d4c7ebd4dc6062bb3db008">&#9670;&#160;</a></span>is_detected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class Op, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">detail::is_detected</a> = typedef typename <a class="el" href="structdetail_1_1detector.html">detector</a>&lt;<a class="el" href="structdetail_1_1nonesuch.html">nonesuch</a>, void, Op, Args...&gt;<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">::value_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a599dfec0fd1c4cc9fcaa98e6fc804e7f" name="a599dfec0fd1c4cc9fcaa98e6fc804e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599dfec0fd1c4cc9fcaa98e6fc804e7f">&#9670;&#160;</a></span>is_detected_convertible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , template&lt; class... &gt; class Op, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a599dfec0fd1c4cc9fcaa98e6fc804e7f">detail::is_detected_convertible</a> = typedef std::is_convertible&lt;<a class="el" href="namespacedetail.html#a9d7d25c4bee06898292dff4eb4e381bf">detected_t</a>&lt;Op, Args...&gt;, To&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f0f7c3e1f48f7df9b5bbceada5b1a07" name="a0f0f7c3e1f48f7df9b5bbceada5b1a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0f7c3e1f48f7df9b5bbceada5b1a07">&#9670;&#160;</a></span>is_detected_exact</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expected , template&lt; class... &gt; class Op, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a0f0f7c3e1f48f7df9b5bbceada5b1a07">detail::is_detected_exact</a> = typedef std::is_same&lt;Expected, <a class="el" href="namespacedetail.html#a9d7d25c4bee06898292dff4eb4e381bf">detected_t</a>&lt;Op, Args...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d62ae589bb3ae01d156629c0b58b0f2" name="a6d62ae589bb3ae01d156629c0b58b0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d62ae589bb3ae01d156629c0b58b0f2">&#9670;&#160;</a></span>is_json_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a6d62ae589bb3ae01d156629c0b58b0f2">detail::is_json_pointer</a> = typedef <a class="el" href="structdetail_1_1is__specialization__of.html">is_specialization_of</a>&lt;::nlohmann::json_pointer, <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">uncvref_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a394f5970957ff03ced71ce77b9417b00" name="a394f5970957ff03ced71ce77b9417b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394f5970957ff03ced71ce77b9417b00">&#9670;&#160;</a></span>is_usable_as_basic_json_key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename KeyTypeCVRef , bool RequireTransparentComparator = true, bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType  = uncvref_t&lt;KeyTypeCVRef&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a394f5970957ff03ced71ce77b9417b00">detail::is_usable_as_basic_json_key_type</a> = typedef typename std::conditional &lt; <a class="el" href="namespacedetail.html#a9d80ed747c2ea999c378519a7a6d6d31">is_usable_as_key_type</a>&lt;typename BasicJsonType::object_comparator_t, typename BasicJsonType::object_t::key_type, KeyTypeCVRef, RequireTransparentComparator, ExcludeObjectKeyType&gt;::value &amp;&amp; !<a class="el" href="structdetail_1_1is__json__iterator__of.html">is_json_iterator_of</a>&lt;BasicJsonType, KeyType&gt;::value, std::true_type, std::false_type &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d80ed747c2ea999c378519a7a6d6d31" name="a9d80ed747c2ea999c378519a7a6d6d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d80ed747c2ea999c378519a7a6d6d31">&#9670;&#160;</a></span>is_usable_as_key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Comparator , typename ObjectKeyType , typename KeyTypeCVRef , bool RequireTransparentComparator = true, bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType  = uncvref_t&lt;KeyTypeCVRef&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a9d80ed747c2ea999c378519a7a6d6d31">detail::is_usable_as_key_type</a> = typedef typename std::conditional &lt; <a class="el" href="structdetail_1_1is__comparable.html">is_comparable</a>&lt;Comparator, ObjectKeyType, KeyTypeCVRef&gt;::value &amp;&amp; !(ExcludeObjectKeyType &amp;&amp; std::is_same&lt;KeyType, ObjectKeyType&gt;::value) &amp;&amp; (!RequireTransparentComparator || <a class="el" href="namespacedetail.html#af040ff7b29d4c7ebd4dc6062bb3db008">is_detected</a> &lt;<a class="el" href="namespacedetail.html#add6a1fa89738d39f7f123db6bad96101">detect_is_transparent</a>, Comparator&gt;::value) &amp;&amp; !<a class="el" href="namespacedetail.html#a6d62ae589bb3ae01d156629c0b58b0f2">is_json_pointer</a>&lt;KeyType&gt;::value, std::true_type, std::false_type &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2e68a64b10d08b88f50a96c4f968be2" name="aa2e68a64b10d08b88f50a96c4f968be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e68a64b10d08b88f50a96c4f968be2">&#9670;&#160;</a></span>iterator_category_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#aa2e68a64b10d08b88f50a96c4f968be2">detail::iterator_category_t</a> = typedef typename T::iterator_category</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70f53d4fa21096275fc0e3016e27daf1" name="a70f53d4fa21096275fc0e3016e27daf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f53d4fa21096275fc0e3016e27daf1">&#9670;&#160;</a></span>iterator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a70f53d4fa21096275fc0e3016e27daf1">detail::iterator_t</a> = typedef <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt;<a class="el" href="structdetail_1_1is__range.html">is_range</a>&lt;R&gt;::value, result_of_begin&lt;decltype(std::declval&lt;R&amp;&gt;())&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0ea2ae325b8654ea5ce36e2c5043f0a" name="ae0ea2ae325b8654ea5ce36e2c5043f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ea2ae325b8654ea5ce36e2c5043f0a">&#9670;&#160;</a></span>json_base_class</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#ae0ea2ae325b8654ea5ce36e2c5043f0a">detail::json_base_class</a> = typedef typename std::conditional &lt; std::is_same&lt;T, void&gt;::value, <a class="el" href="structdetail_1_1json__default__base.html">json_default_base</a>, T &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e60ec97eaa2afdff62c6217cbbbd747" name="a8e60ec97eaa2afdff62c6217cbbbd747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e60ec97eaa2afdff62c6217cbbbd747">&#9670;&#160;</a></span>key_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a8e60ec97eaa2afdff62c6217cbbbd747">detail::key_type_t</a> = typedef typename T::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82dd889f447e7a1383b8757be27f66e9" name="a82dd889f447e7a1383b8757be27f66e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dd889f447e7a1383b8757be27f66e9">&#9670;&#160;</a></span>make_index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a82dd889f447e7a1383b8757be27f66e9">detail::make_index_sequence</a> = typedef <a class="el" href="namespacedetail.html#a517a072d9de78dcbc9c44c39f75a0d92">make_integer_sequence</a>&lt;size_t, N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a517a072d9de78dcbc9c44c39f75a0d92" name="a517a072d9de78dcbc9c44c39f75a0d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517a072d9de78dcbc9c44c39f75a0d92">&#9670;&#160;</a></span>make_integer_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a517a072d9de78dcbc9c44c39f75a0d92">detail::make_integer_sequence</a> = typedef typename <a class="el" href="structdetail_1_1utility__internal_1_1Gen.html">utility_internal::Gen</a>&lt;T, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f0f5d9b1fa1f5ed1be64165f3cf887f" name="a6f0f5d9b1fa1f5ed1be64165f3cf887f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0f5d9b1fa1f5ed1be64165f3cf887f">&#9670;&#160;</a></span>mapped_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a6f0f5d9b1fa1f5ed1be64165f3cf887f">detail::mapped_type_t</a> = typedef typename T::mapped_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af80e4e59be493e62842fb40354351e8b" name="af80e4e59be493e62842fb40354351e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80e4e59be493e62842fb40354351e8b">&#9670;&#160;</a></span>never_out_of_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OfType , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#af80e4e59be493e62842fb40354351e8b">detail::never_out_of_range</a> = typedef std::integral_constant &lt; bool, (std::is_signed&lt;OfType&gt;::value &amp;&amp; (sizeof(T) &lt; sizeof(OfType))) || (<a class="el" href="namespacedetail.html#a91e73e1b9fba3c45b9ad1b0b7f4f1c9b">same_sign</a>&lt;OfType, T&gt;::value &amp;&amp; sizeof(OfType) == sizeof(T)) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41f3f767ccb40a3a5db595b172207340" name="a41f3f767ccb40a3a5db595b172207340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f3f767ccb40a3a5db595b172207340">&#9670;&#160;</a></span>pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a41f3f767ccb40a3a5db595b172207340">detail::pointer_t</a> = typedef typename T::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2653c739e3ac41529a35735397b4f41" name="ac2653c739e3ac41529a35735397b4f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2653c739e3ac41529a35735397b4f41">&#9670;&#160;</a></span>range_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#ac2653c739e3ac41529a35735397b4f41">detail::range_value_t</a> = typedef <a class="el" href="namespacedetail.html#a53f74b6382403d25215a9433897255b4">value_type_t</a>&lt;<a class="el" href="structdetail_1_1iterator__traits.html">iterator_traits</a>&lt;<a class="el" href="namespacedetail.html#a70f53d4fa21096275fc0e3016e27daf1">iterator_t</a>&lt;T&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae10a42b2797e1b62417091ff3d330832" name="ae10a42b2797e1b62417091ff3d330832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10a42b2797e1b62417091ff3d330832">&#9670;&#160;</a></span>reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#ae10a42b2797e1b62417091ff3d330832">detail::reference_t</a> = typedef typename T::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91e73e1b9fba3c45b9ad1b0b7f4f1c9b" name="a91e73e1b9fba3c45b9ad1b0b7f4f1c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e73e1b9fba3c45b9ad1b0b7f4f1c9b">&#9670;&#160;</a></span>same_sign</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a91e73e1b9fba3c45b9ad1b0b7f4f1c9b">detail::same_sign</a> = typedef std::integral_constant &lt; bool, <a class="el" href="namespacedetail.html#ac78ba866159e98c93c50a9a1140901dc">all_signed</a>&lt;Types...&gt;::value || <a class="el" href="namespacedetail.html#a804e13d43be14f983b738e18f0bb8eb9">all_unsigned</a>&lt;Types...&gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf4c26a378982200b0f5e74a896366da" name="acf4c26a378982200b0f5e74a896366da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4c26a378982200b0f5e74a896366da">&#9670;&#160;</a></span>string_can_append</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#acf4c26a378982200b0f5e74a896366da">detail::string_can_append</a> = typedef decltype(std::declval&lt;StringType&amp;&gt;().append(std::declval &lt; Arg &amp;&amp; &gt; ()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed2aa53ac9a71b89c3d6931de1d8fab6" name="aed2aa53ac9a71b89c3d6931de1d8fab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2aa53ac9a71b89c3d6931de1d8fab6">&#9670;&#160;</a></span>string_can_append_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#aed2aa53ac9a71b89c3d6931de1d8fab6">detail::string_can_append_data</a> = typedef decltype(std::declval&lt;StringType&amp;&gt;().append(std::declval&lt;const Arg&amp;&gt;().data(), std::declval&lt;const Arg&amp;&gt;().size()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e6d98622b8133a6c4b873556cb55a9a" name="a9e6d98622b8133a6c4b873556cb55a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6d98622b8133a6c4b873556cb55a9a">&#9670;&#160;</a></span>string_can_append_iter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a9e6d98622b8133a6c4b873556cb55a9a">detail::string_can_append_iter</a> = typedef decltype(std::declval&lt;StringType&amp;&gt;().append(std::declval&lt;const Arg&amp;&gt;().begin(), std::declval&lt;const Arg&amp;&gt;().end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19c834c5cfd6433e7d65371d1bc99972" name="a19c834c5cfd6433e7d65371d1bc99972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c834c5cfd6433e7d65371d1bc99972">&#9670;&#160;</a></span>string_can_append_op</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a19c834c5cfd6433e7d65371d1bc99972">detail::string_can_append_op</a> = typedef decltype(std::declval&lt;StringType&amp;&gt;() += std::declval &lt; Arg &amp;&amp; &gt; ())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30a52995475a3d1522a15e7a8200c59e" name="a30a52995475a3d1522a15e7a8200c59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a52995475a3d1522a15e7a8200c59e">&#9670;&#160;</a></span>to_json_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a30a52995475a3d1522a15e7a8200c59e">detail::to_json_function</a> = typedef decltype(T::to_json(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad76afb2c3a23eb88e7efb7c5d5499574" name="ad76afb2c3a23eb88e7efb7c5d5499574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76afb2c3a23eb88e7efb7c5d5499574">&#9670;&#160;</a></span>uncvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a> = typedef typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53f74b6382403d25215a9433897255b4" name="a53f74b6382403d25215a9433897255b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f74b6382403d25215a9433897255b4">&#9670;&#160;</a></span>value_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a53f74b6382403d25215a9433897255b4">detail::value_type_t</a> = typedef typename T::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a138aa0af34e28b5a1032f00c712d376b" name="a138aa0af34e28b5a1032f00c712d376b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138aa0af34e28b5a1032f00c712d376b">&#9670;&#160;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedetail.html#a138aa0af34e28b5a1032f00c712d376b">detail::void_t</a> = typedef typename <a class="el" href="structdetail_1_1make__void.html">make_void</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7c070b2bf3d61e3d8b8013f6fb18d592" name="a7c070b2bf3d61e3d8b8013f6fb18d592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c070b2bf3d61e3d8b8013f6fb18d592">&#9670;&#160;</a></span>cbor_tag_handler_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">detail::cbor_tag_handler_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>how to treat CBOR tags </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282" name="a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282"></a>error&#160;</td><td class="fielddoc"><p>throw a <a class="el" href="classdetail_1_1parse__error.html" title="exception indicating a parse error">parse_error</a> exception in case of a tag </p>
</td></tr>
<tr><td class="fieldname"><a id="a7c070b2bf3d61e3d8b8013f6fb18d592a567bc1d268f135496de3d5b946b691f3" name="a7c070b2bf3d61e3d8b8013f6fb18d592a567bc1d268f135496de3d5b946b691f3"></a>ignore&#160;</td><td class="fielddoc"><p>ignore tags </p>
</td></tr>
<tr><td class="fieldname"><a id="a7c070b2bf3d61e3d8b8013f6fb18d592a8cd892b7b97ef9489ae4479d3f4ef0fc" name="a7c070b2bf3d61e3d8b8013f6fb18d592a8cd892b7b97ef9489ae4479d3f4ef0fc"></a>store&#160;</td><td class="fielddoc"><p>store tags as binary type </p>
</td></tr>
</table>

</div>
</div>
<a id="abe7cfa1fd8fa706ff4392bff9d1a8298" name="abe7cfa1fd8fa706ff4392bff9d1a8298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7cfa1fd8fa706ff4392bff9d1a8298">&#9670;&#160;</a></span>error_handler_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">detail::error_handler_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>how to treat decoding errors </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792" name="abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792"></a>strict&#160;</td><td class="fielddoc"><p>throw a <a class="el" href="classdetail_1_1type__error.html" title="exception indicating executing a member function with a wrong type">type_error</a> exception in case of invalid UTF-8 </p>
</td></tr>
<tr><td class="fieldname"><a id="abe7cfa1fd8fa706ff4392bff9d1a8298a9dde360102c103867bd2f45872f1129c" name="abe7cfa1fd8fa706ff4392bff9d1a8298a9dde360102c103867bd2f45872f1129c"></a>replace&#160;</td><td class="fielddoc"><p>replace invalid UTF-8 sequences with U+FFFD </p>
</td></tr>
<tr><td class="fieldname"><a id="abe7cfa1fd8fa706ff4392bff9d1a8298a567bc1d268f135496de3d5b946b691f3" name="abe7cfa1fd8fa706ff4392bff9d1a8298a567bc1d268f135496de3d5b946b691f3"></a>ignore&#160;</td><td class="fielddoc"><p>ignore invalid UTF-8 sequences </p>
</td></tr>
</table>

</div>
</div>
<a id="a917c3efabea8a20dc72d9ae2c673d632" name="a917c3efabea8a20dc72d9ae2c673d632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917c3efabea8a20dc72d9ae2c673d632">&#9670;&#160;</a></span>value_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the JSON type enumeration </p>
<p>This enumeration collects the different JSON types. It is internally used to distinguish the stored values, and the functions <a class="el" href="classbasic__json.html#ad8789d0a365d5afaab61e7492908d8b2">basic_json::is_null()</a>, <a class="el" href="classbasic__json.html#af355a2b131068acf3d623eb6d80a711c">basic_json::is_object()</a>, <a class="el" href="classbasic__json.html#a184ba4a6b47e6da3703af19349bd776f">basic_json::is_array()</a>, <a class="el" href="classbasic__json.html#a007ecebde9a7d40714e300ce0ff52908">basic_json::is_string()</a>, <a class="el" href="classbasic__json.html#acfe2e3c359b545f8edbb72f6bd78718c">basic_json::is_boolean()</a>, <a class="el" href="classbasic__json.html#aacf244be5088fb183f4ba21a66af9631">basic_json::is_number()</a> (with <a class="el" href="classbasic__json.html#a2330e35cda16540058fef090abc709bf">basic_json::is_number_integer()</a>, <a class="el" href="classbasic__json.html#a4de72635745144ee519157d23fe7189a">basic_json::is_number_unsigned()</a>, and <a class="el" href="classbasic__json.html#a8d5bb82dfc8cceae1753b52a588eef92">basic_json::is_number_float()</a>), <a class="el" href="classbasic__json.html#a39e4946a414cc978b88939ed1b343d46">basic_json::is_discarded()</a>, <a class="el" href="classbasic__json.html#ad650dd5a7e019b970abce3d8864b5654">basic_json::is_primitive()</a>, and <a class="el" href="classbasic__json.html#a2d3a5f8761bc6f163f4119bddaf7b092">basic_json::is_structured()</a> rely on it.</p>
<dl class="section note"><dt>Note</dt><dd>There are three enumeration entries (number_integer, number_unsigned, and number_float), because the library distinguishes these three types for numbers: <a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">basic_json::number_unsigned_t</a> is used for unsigned integers, <a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">basic_json::number_integer_t</a> is used for signed integers, and <a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">basic_json::number_float_t</a> is used for floating-point numbers or to approximate integers which do not fit in the limits of their respective type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>see <a class="el" href="classbasic__json.html#ae2d5bc42270881ed3e219e8b1456fec5">basic_json::basic_json(const value_t value_type)</a> &ndash; create a JSON value with the default value for a given type</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd" name="a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd"></a>null&#160;</td><td class="fielddoc"><p>null value </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666" name="a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666"></a>object&#160;</td><td class="fielddoc"><p>object (unordered set of name/value pairs) </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5" name="a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5"></a>array&#160;</td><td class="fielddoc"><p>array (ordered collection of values) </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21" name="a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21"></a>string&#160;</td><td class="fielddoc"><p>string value </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27" name="a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27"></a>boolean&#160;</td><td class="fielddoc"><p>boolean value </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc" name="a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc"></a>number_integer&#160;</td><td class="fielddoc"><p>number value (signed integer) </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e" name="a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e"></a>number_unsigned&#160;</td><td class="fielddoc"><p>number value (unsigned integer) </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef" name="a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef"></a>number_float&#160;</td><td class="fielddoc"><p>number value (floating-point) </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20" name="a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20"></a>binary&#160;</td><td class="fielddoc"><p>binary array (ordered collection of bytes) </p>
</td></tr>
<tr><td class="fieldname"><a id="a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46" name="a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46"></a>discarded&#160;</td><td class="fielddoc"><p>discarded by the parser callback function </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a266fb3d4bf633ad6c506434cc91164da" name="a266fb3d4bf633ad6c506434cc91164da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266fb3d4bf633ad6c506434cc91164da">&#9670;&#160;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutStringType  = std::string, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutStringType detail::concat </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89f967b745cf8df11ba9d59f93d97753" name="a89f967b745cf8df11ba9d59f93d97753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f967b745cf8df11ba9d59f93d97753">&#9670;&#160;</a></span>concat_into() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutStringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::concat_into </td>
          <td>(</td>
          <td class="paramtype">OutStringType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa16fc2d4a149a0e3ac68ceb98b153815" name="aa16fc2d4a149a0e3ac68ceb98b153815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16fc2d4a149a0e3ac68ceb98b153815">&#9670;&#160;</a></span>concat_into() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutStringType , typename Arg , typename... Args, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; !<a class="el" href="namespacedetail.html#afa4e2beed41963eb3fc4a270821633f3">detect_string_can_append</a>&lt; OutStringType, Arg &gt;::value &amp;&amp;<a class="el" href="namespacedetail.html#a4c5c0042966002d3d0a653b504cf95da">detect_string_can_append_op</a>&lt; OutStringType, Arg &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::concat_into </td>
          <td>(</td>
          <td class="paramtype">OutStringType &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78434fad7c03e66afdd06a6df628315a" name="a78434fad7c03e66afdd06a6df628315a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78434fad7c03e66afdd06a6df628315a">&#9670;&#160;</a></span>concat_into() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutStringType , typename Arg , typename... Args, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; !<a class="el" href="namespacedetail.html#afa4e2beed41963eb3fc4a270821633f3">detect_string_can_append</a>&lt; OutStringType, Arg &gt;::value &amp;&amp;!<a class="el" href="namespacedetail.html#a4c5c0042966002d3d0a653b504cf95da">detect_string_can_append_op</a>&lt; OutStringType, Arg &gt;::value &amp;&amp;<a class="el" href="namespacedetail.html#a2a2fa7cb837caf838593444fe0d910b7">detect_string_can_append_iter</a>&lt; OutStringType, Arg &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::concat_into </td>
          <td>(</td>
          <td class="paramtype">OutStringType &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac185140ed8c8fcc07a302a890b714b0d" name="ac185140ed8c8fcc07a302a890b714b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac185140ed8c8fcc07a302a890b714b0d">&#9670;&#160;</a></span>concat_length() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t detail::concat_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d26947197a0f2d23110a4f40bd90d85" name="a5d26947197a0f2d23110a4f40bd90d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d26947197a0f2d23110a4f40bd90d85">&#9670;&#160;</a></span>concat_length() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t detail::concat_length </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5f189c556ba621b4bbb57fe03cd4800" name="aa5f189c556ba621b4bbb57fe03cd4800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f189c556ba621b4bbb57fe03cd4800">&#9670;&#160;</a></span>concat_length() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t detail::concat_length </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cd92967d2de985b74ce05092fc21680" name="a3cd92967d2de985b74ce05092fc21680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd92967d2de985b74ce05092fc21680">&#9670;&#160;</a></span>concat_length() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t detail::concat_length </td>
          <td>(</td>
          <td class="paramtype">const StringType &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d17f1d261bd9fec64c08343c9f809fc" name="a5d17f1d261bd9fec64c08343c9f809fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d17f1d261bd9fec64c08343c9f809fc">&#9670;&#160;</a></span>conditional_static_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; !std::is_same&lt; T, U &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T detail::conditional_static_cast </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2a9ce4740e0b45d33129e2c8e53a0a8" name="af2a9ce4740e0b45d33129e2c8e53a0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a9ce4740e0b45d33129e2c8e53a0a8">&#9670;&#160;</a></span>escape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringType detail::escape </td>
          <td>(</td>
          <td class="paramtype">StringType&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>string escaping as described in RFC 6901 (Sect. 4) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>string to escape </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>escaped string</dd></dl>
<p>Note the order of escaping "~" to "~0" and "/" to "~1" is important. </p>

</div>
</div>
<a id="a7116703ea757fe9821bf2e903b91c160" name="a7116703ea757fe9821bf2e903b91c160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7116703ea757fe9821bf2e903b91c160">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename IteratorType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; N==0, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto detail::get </td>
          <td>(</td>
          <td class="paramtype">const nlohmann::detail::iteration_proxy_value&lt; IteratorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> -&gt; decltype(i.key())
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af75fd8de21cdb8a0ed835b94aa02e5da" name="af75fd8de21cdb8a0ed835b94aa02e5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75fd8de21cdb8a0ed835b94aa02e5da">&#9670;&#160;</a></span>int_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename string_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void detail::int_to_string </td>
          <td>(</td>
          <td class="paramtype">string_type &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a6920228c2b39db99481d6952ca1add" name="a9a6920228c2b39db99481d6952ca1add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6920228c2b39db99481d6952ca1add">&#9670;&#160;</a></span>little_endianness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool detail::little_endianness </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determine system byte order </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if system's byte order is little endian</dd></dl>
<dl class="section note"><dt>Note</dt><dd>from <a href="https://stackoverflow.com/a/1001328/266378">https://stackoverflow.com/a/1001328/266378</a> </dd></dl>

</div>
</div>
<a id="a346dced829a9a2b98a722a31c62b3f7a" name="a346dced829a9a2b98a722a31c62b3f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346dced829a9a2b98a722a31c62b3f7a">&#9670;&#160;</a></span>make_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; T, sizeof...(Args)&gt; detail::make_array </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac7ca91589afb0bad68baec5949daaa2" name="aac7ca91589afb0bad68baec5949daaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7ca91589afb0bad68baec5949daaa2">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool detail::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison operator for JSON types </p>
<p>Returns an ordering that is similar to Python:</p><ul>
<li>order: null &lt; boolean &lt; number &lt; object &lt; array &lt; string &lt; binary</li>
<li>furthermore, each type is not smaller than itself</li>
<li>discarded values are not comparable</li>
<li>binary is represented as a b"" string in python and directly comparable to a string; however, making a binary array directly comparable with a string would be surprising behavior in a JSON file.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

</div>
</div>
<a id="a6fd295e53b1dd4f46e235e6afee26d5e" name="a6fd295e53b1dd4f46e235e6afee26d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd295e53b1dd4f46e235e6afee26d5e">&#9670;&#160;</a></span>replace_substring()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::replace_substring </td>
          <td>(</td>
          <td class="paramtype">StringType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringType &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>replace all occurrences of a substring by another string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>the string to manipulate; changed so that all occurrences of <em>f</em> are replaced with <em>t</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the substring to replace with <em>t</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the string to replace <em>f</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The search string <em>f</em> must not be empty. <b>This precondition is enforced with an assertion.</b></dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.0.0 </dd></dl>

</div>
</div>
<a id="aca950b6f8e111cbf473fa0a30b4118a9" name="aca950b6f8e111cbf473fa0a30b4118a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca950b6f8e111cbf473fa0a30b4118a9">&#9670;&#160;</a></span>to_json() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename CompatibleNumberIntegerType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__compatible__integer__type.html">is_compatible_integer_type</a>&lt; typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompatibleNumberIntegerType&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4eec865929224a2edcdd86e0e2f5381" name="af4eec865929224a2edcdd86e0e2f5381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4eec865929224a2edcdd86e0e2f5381">&#9670;&#160;</a></span>to_json() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename CompatibleNumberUnsignedType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__compatible__integer__type.html">is_compatible_integer_type</a>&lt; typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompatibleNumberUnsignedType&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a432a72eacdbf2e603aadbef62b0693e5" name="a432a72eacdbf2e603aadbef62b0693e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432a72eacdbf2e603aadbef62b0693e5">&#9670;&#160;</a></span>to_json() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename BoolRef , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt;((std::is_same&lt; std::vector&lt; bool &gt;::reference, BoolRef &gt;::value &amp;&amp;!std::is_same&lt; std::vector&lt; bool &gt;::reference, typename BasicJsonType::boolean_t &amp; &gt;::value)||(std::is_same&lt; std::vector&lt; bool &gt;::const_reference, BoolRef &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#ad76afb2c3a23eb88e7efb7c5d5499574">detail::uncvref_t</a>&lt; std::vector&lt; bool &gt;::const_reference &gt;, typename BasicJsonType::boolean_t &gt;::value)) &amp;&amp;std::is_convertible&lt; const BoolRef &amp;, typename BasicJsonType::boolean_t &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoolRef &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13eaa461d3df66f08b281ed8ef67443d" name="a13eaa461d3df66f08b281ed8ef67443d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13eaa461d3df66f08b281ed8ef67443d">&#9670;&#160;</a></span>to_json() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename CompatibleArrayType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__compatible__array__type.html">is_compatible_array_type</a>&lt; BasicJsonType, CompatibleArrayType &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__compatible__object__type.html">is_compatible_object_type</a>&lt; BasicJsonType, CompatibleArrayType &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__compatible__string__type.html">is_compatible_string_type</a>&lt; BasicJsonType, CompatibleArrayType &gt;::value &amp;&amp;!std::is_same&lt; typename BasicJsonType::binary_t, CompatibleArrayType &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__basic__json.html">is_basic_json</a>&lt; CompatibleArrayType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompatibleArrayType &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a210ddcd90b4d42832abc02eb516c4d99" name="a210ddcd90b4d42832abc02eb516c4d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ddcd90b4d42832abc02eb516c4d99">&#9670;&#160;</a></span>to_json() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename CompatibleObjectType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; <a class="el" href="structdetail_1_1is__compatible__object__type.html">is_compatible_object_type</a>&lt; BasicJsonType, CompatibleObjectType &gt;::value &amp;&amp;!<a class="el" href="structdetail_1_1is__basic__json.html">is_basic_json</a>&lt; CompatibleObjectType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompatibleObjectType &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c8440d5ee74cd66effc302294a0f03a" name="a5c8440d5ee74cd66effc302294a0f03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8440d5ee74cd66effc302294a0f03a">&#9670;&#160;</a></span>to_json() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename CompatibleString , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_constructible&lt; typename BasicJsonType::string_t, CompatibleString &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompatibleString &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade7a3840a7af072111b938aafefa4bef" name="ade7a3840a7af072111b938aafefa4bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7a3840a7af072111b938aafefa4bef">&#9670;&#160;</a></span>to_json() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename T1 , typename T2 , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_constructible&lt; BasicJsonType, T1 &gt;::value &amp;&amp;std::is_constructible&lt; BasicJsonType, T2 &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71164c6a1be656ae46c8a48a9f4f024f" name="a71164c6a1be656ae46c8a48a9f4f024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71164c6a1be656ae46c8a48a9f4f024f">&#9670;&#160;</a></span>to_json() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename T , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_convertible&lt; T, BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a898665fe3505e4124ee130ac40b5f7c2" name="a898665fe3505e4124ee130ac40b5f7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898665fe3505e4124ee130ac40b5f7c2">&#9670;&#160;</a></span>to_json() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f5949a32eedf94fb0b98fd189fda0d6" name="a3f5949a32eedf94fb0b98fd189fda0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5949a32eedf94fb0b98fd189fda0d6">&#9670;&#160;</a></span>to_json() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename T , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_same&lt; T, <a class="el" href="classdetail_1_1iteration__proxy__value.html">iteration_proxy_value</a>&lt; typename BasicJsonType::iterator &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a120fee99373c660eb270811fd26226c8" name="a120fee99373c660eb270811fd26226c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120fee99373c660eb270811fd26226c8">&#9670;&#160;</a></span>to_json() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename T , std::size_t N, <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; !std::is_constructible&lt; typename BasicJsonType::string_t, const T(&amp;)[N]&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>arr</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac4c34558512e0288775fefb01900d24" name="aac4c34558512e0288775fefb01900d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4c34558512e0288775fefb01900d24">&#9670;&#160;</a></span>to_json() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename BasicJsonType::binary_t &amp;&#160;</td>
          <td class="paramname"><em>bin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0aa73b51ab32301503f808871a7d1130" name="a0aa73b51ab32301503f808871a7d1130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa73b51ab32301503f808871a7d1130">&#9670;&#160;</a></span>to_json() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename EnumType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_enum&lt; EnumType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnumType&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fd79e26a03ad0f6f014acde6ca955ab" name="a0fd79e26a03ad0f6f014acde6ca955ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd79e26a03ad0f6f014acde6ca955ab">&#9670;&#160;</a></span>to_json() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename FloatType , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_floating_point&lt; FloatType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfdf2e4c8f09d5acaa2841358db51f82" name="acfdf2e4c8f09d5acaa2841358db51f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdf2e4c8f09d5acaa2841358db51f82">&#9670;&#160;</a></span>to_json() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename T , <a class="el" href="namespacedetail.html#a66bbcd629c83a87ba9cbc72a675cf84a">enable_if_t</a>&lt; std::is_same&lt; T, typename BasicJsonType::boolean_t &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee383505e04bd7c68d4a288870147ff4" name="aee383505e04bd7c68d4a288870147ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee383505e04bd7c68d4a288870147ff4">&#9670;&#160;</a></span>to_json() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename BasicJsonType::array_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48b6774b5ab06f17f77c683d85f0b0b2" name="a48b6774b5ab06f17f77c683d85f0b0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b6774b5ab06f17f77c683d85f0b0b2">&#9670;&#160;</a></span>to_json() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename BasicJsonType::object_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4efa05c0a1af490d3cd2244ab1ec2935" name="a4efa05c0a1af490d3cd2244ab1ec2935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efa05c0a1af490d3cd2244ab1ec2935">&#9670;&#160;</a></span>to_json() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename BasicJsonType::string_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d4851287a8b8b21ca8605d31ca446ea" name="a0d4851287a8b8b21ca8605d31ca446ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4851287a8b8b21ca8605d31ca446ea">&#9670;&#160;</a></span>to_json_tuple_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicJsonType , typename Tuple , std::size_t... Idx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void detail::to_json_tuple_impl </td>
          <td>(</td>
          <td class="paramtype">BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a4e6f1f2e94159041593901afc8f0c9b0">index_sequence</a>&lt; Idx... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e971234e72db1e314aa87298e84d1d0" name="a0e971234e72db1e314aa87298e84d1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e971234e72db1e314aa87298e84d1d0">&#9670;&#160;</a></span>unescape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void detail::unescape </td>
          <td>(</td>
          <td class="paramtype">StringType &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>string unescaping as described in RFC 6901 (Sect. 4) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>string to unescape </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unescaped string</dd></dl>
<p>Note the order of escaping "~1" to "/" and "~0" to "~" is important. </p>

</div>
</div>
<a id="a8e7a4119c6c8e86cef8f1c904c8bf040" name="a8e7a4119c6c8e86cef8f1c904c8bf040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7a4119c6c8e86cef8f1c904c8bf040">&#9670;&#160;</a></span>value_in_range_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OfType , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool detail::value_in_range_of </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
